<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="author" content="Ebeid ElSayed" />
    <meta name="description" content="Ebeid&#39;s website">
    <link rel="shortcut icon" type="image/x-icon" href="https://ebeid.github.io/img/favicon.ico">
    <title>Log4net Extended Tutorial</title>
    <meta name="generator" content="Hugo 0.69.0" />
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="https://ebeid.github.io/css/main.css" />
    <link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" />
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,400,200bold,400old" />
    
    <!--[if lt IE 9]>
			<script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
			<script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
		<![endif]-->

    
  </head>

  <body>
    <div id="wrap">

      
      <nav class="navbar navbar-default">
  <div class="container">
    <div class="navbar-header">
      <a class="navbar-brand" href="https://ebeid.github.io/"><i class="fa fa-home"></i></a>
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <div class="navbar-collapse collapse" id="navbar">
      <ul class="nav navbar-nav navbar-right">
      
        
        <li><a href="/blog/">BLOG</a></li>
        
        <li><a href="/projects/">PROJECTS</a></li>
        
        <li><a href="/pdf/resume.pdf">RESUME</a></li>
        
      
      </ul>
    </div>
  </div>
</nav>

      
      <div class="container">
        <div class="blog-post">
          <h3>
            <strong><a href="https://ebeid.github.io/blog/2011-10-16-log4net-extended-tutorial.html/">Log4net Extended Tutorial</a></strong>
          </h3>
        </div>
        <div class="blog-title">
          <h4>
          October 16, 2011
            &nbsp;&nbsp;
            
          </h4>
        </div>
        <div class="panel panel-default">
          <div class="panel-body">
            <div class="blogpost">
              <p>Logging is one of the most effective debugging and troubleshooting
techniques although some engineers claim that it is not that helpful or
it will slow the application. My experience with it is always positive.</p>
<p>I use <a href="http://logging.apache.org/log4net/index.html">log4net</a> from the
<a href="http://www.apache.org/">Apache Software Foundation</a> as my logging layer
for .Net applications. log4net is available
<a href="http://logging.apache.org/log4net/download.html">here</a> as a zip
archive.</p>
<h5 id="hello-world-example-uses-basicconfigurator">Hello World Example [uses <em>BasicConfigurator</em>]</h5>
<ol>
<li>
<p>Download log4net from
<a href="http://logging.apache.org/log4net/download.html">here</a>.</p>
</li>
<li>
<p>Open Visual Studio and create a new Console application project.</p>
</li>
<li>
<p>Add to the project a reference to the
\bin\net\2.0\release\log4net.dll assembly in the log4net
distribution.</p>
</li>
<li>
<p>Modify your Main() method like so:</p>
<p>1:  using System;</p>
<p>2:  namespace ConsoleApplication1</p>
<p>3:  {</p>
<p>4:      class Program</p>
<p>5:      {</p>
<p>6:          static void Main(string[] args)</p>
<p>7:          {</p>
<p>8:              log4net.Config.BasicConfigurator.Configure();</p>
<p>9:              log4net.ILog log = log4net.LogManager.GetLogger(typeof(Program));</p>
<p>10:   </p>
<p>11:              log.Debug(&ldquo;Hello World!&quot;);</p>
<p>12:              log.Info(&ldquo;Just info.&quot;);</p>
<p>13:              log.Warn(&ldquo;careful this is a warning.&quot;);</p>
<p>14:              log.Error(&ldquo;Bad news: Error occurred.&quot;);</p>
<p>15:              log.Fatal(&ldquo;Here is the end.&quot;);</p>
<p>16:          }</p>
<p>17:      }</p>
<p>18:  }</p>
</li>
</ol>
<p>Compile and run the application, and you&rsquo;ll see output to the console
like so:</p>
<p><a href="http://lh5.ggpht.com/-1HbirpfdUDI/TpuXZavA1pI/AAAAAAAAAIA/c8JwR4YM8p8/s1600-h/log4net14.jpg"><!-- raw HTML omitted --></a></p>
<p>In the Hello World example we configured log4net in the most basic way
possible just to get started. Using the BasicConfigurator (line 8) will
cause log4net to output log entries to the console using the default
layout. Line 9 requests a <em>logger</em> from the LogManager object.  Logger
objects implement the ILog interface, which is what your application
will use to instrument itself and percolate log entries.</p>
<p>Lines 11-15 use the logger to log a few statements with various
<em>severity levels</em>.  log4net defines 5 such levels:</p>
<ul>
<li><strong>Debug</strong>: fine-grained statements concerning program state,
typically used for debugging;</li>
<li><strong>Info</strong>: informational statements concerning program state,
representing program events or behavior tracking;</li>
<li><strong>Warn</strong>: statements that describe potentially harmful events or
states in the program;</li>
<li><strong>Error</strong>: statements that describe non-fatal errors in the
application; this level is used quite often for logging handled
exceptions;</li>
<li><strong>Fatal</strong>: statements representing the most severe of error
conditions, assumedly resulting in program termination.</li>
</ul>
<h5 id="xml-configurator">XML Configurator</h5>
<p>In the previous example we used the BasicConfigurator. If we just
changed the configurator to XmlConfigurator and run the application you
will get the following output error:</p>
<p>log4net:ERROR XmlConfigurator: Failed to find configuration section
&lsquo;log4net&rsquo; in</p>
<p>the application&rsquo;s .config file. Check your .config file for the
&lt;log4net&gt; and &lt;</p>
<p>configSections&gt; elements. The configuration section should look like:
&lt;section n</p>
<p>ame=&quot;log4net&rdquo;
type=&quot;log4net.Config.Log4NetConfigurationSectionHandler,log4net&rdquo; /</p>
<p>&gt;</p>
<p>This error resulted because XMLConfigurator relies on an XML document to
supply configuration for log4net. The static Configure method have 10
overloads to accept the XML configuration from a file, stream, URI, or
an XmlElement object. The parameterless overload of the method we used
instructs log4net to load the XML from the application’s configuration
file. Since our application doesn’t contain any configuration files
(till now), the Configure method returned the above error.</p>
<p>To overcome this error, add Application Configuration File to the
project and add the following XML configuration:</p>
<pre><code>   1:  &lt;configuration&gt;  




   2:    &lt;configSections&gt;  




   3:      &lt;section name=&quot;log4net&quot; type=&quot;log4net.Config.Log4NetConfigurationSectionHandler, log4net&quot;/&gt;  




   4:    &lt;/configSections&gt;  




   5:    




   6:    &lt;log4net&gt;  




   7:      &lt;appender name=&quot;ConsoleAppender&quot; type=&quot;log4net.Appender.ConsoleAppender&quot;&gt;  




   8:        &lt;layout type=&quot;log4net.Layout.SimpleLayout&quot; /&gt;  




   9:      &lt;/appender&gt;  




  10:    




  11:      &lt;root&gt;  




  12:        &lt;level value=&quot;ALL&quot; /&gt;  




  13:        &lt;appender-ref ref=&quot;ConsoleAppender&quot; /&gt;  




  14:      &lt;/root&gt;  




  15:    &lt;/log4net&gt;  




  16:  &lt;/configuration&gt;  
</code></pre>
<p>Compile and run, you will see output changed to be like so:</p>
<p><a href="http://lh6.ggpht.com/-841B0VRGiM0/TpuXaEEWiPI/AAAAAAAAAIQ/EN4zl87Vh7U/s1600-h/log4net26.jpg"><!-- raw HTML omitted --></a></p>
<p>In addition to the Configure method, XmlConfigurator offers a static
ConfigureAndWatch() method that accepts a FileInfo reference.
ConfigureAndWatch() will monitor the XML configuration file and
reconfigure log4net when a change is detected in this file.  This allows
you to alter logging behavior while the application is running to fit
your current troubleshooting requirements.</p>
<p>If we look at the application configurations file, the declaration of
the log4net configuration section on line 3 is mandatory. The log4net
configurations section [lines 6-15] consists of two sub-sections:
<em>appender</em> and <em>root.</em> log4net appender is the place where your
application log entries end up (Console in our example). We will talk
about appenders later. The root logger controls the general behavior of
log4net.  In this example, the root logger is told to send everything to
the console appender.</p>
<h5 id="taming-log4net-output">Taming log4net Output</h5>
<p>In the previous examples we were logging all types of severity levels.
If you want to filter the logging output to fit your application’s life
current phase (development, production) or troubleshooting needs, you
can just change the value of &lt;level /&gt; XML element in your
app.config.  The level value instructs the logger of the minimum level
at which log entries should be processed. It can be: ALL (everything is
enabled), DEBUG (identical to ALL), INFO (everything except DEBUG), WARN
(warn, Error, and Fatal), ERROR (Error and Fatal), FATAL (only Fatal),
OFF (logging is disabled).</p>
<h2 id="the-structure-of-log4net">The Structure of log4net</h2>
<p>Before going further with log4net, let’s talk about its structure.
log4net built using the layered approach, with four main components
inside of the framework. These are Logger, Repository, Appender, and
Layout.</p>
<p>The <em>Logger</em> is the main component with which your application
interacts. It is also the component that generates the log messages.</p>
<p>The <em>Repository</em> is responsible for maintaining the logical organization
of loggers inside the framework. Currently log4net only supported the
hierarchical organization through <code>log4net.Repository.Hierarchy</code>
namespace. If you want to extend log4net to implement new organization,
you have to implement the <code>log4net.Repository.ILoggerRepository</code>
interface or inherit class
<code>log4net.Repository.LoggerRepositorySkeleton</code>. Almost all developers do
not use any of these <code>Repository</code> classes; they only use the
<code>LogManager</code> class to automatically manage the repositories and the
loggers.</p>
<p>The <em>Appender</em> is used to define the output medium that log statements
will go for it at the end of the day. As the name suggests, these
components append themselves to the Logger component and relay the
output to an output stream. You can append multiple appenders to a
single logger. There are several appenders provided by the <code>log4net</code>
framework. If you want to write your own appender, you can start by
inheriting the<code>log4net.Appender.AppenderSkeleton</code> class, which works as
an adapter between your class and the <code>IAppender</code> interface. You can use
<em>Appender Filters</em> to filter logging events sent from appenders before
processing it.</p>
<p>The <em>Layout</em> component is used to display the final formatted output to
the user. The output can be shown in multiple formats, depending upon
the layout we are using. It can be linear or an XML file. The layout
component works with an appender. There is a list of different layouts
in the API documentation. You cannot use multiple layouts with an
appender. To create your own layout, you need to inherit
the<code>log4net.Layout.LayoutSkeleton</code> class, which implements the <code>ILayout</code>
interface.</p>
<h2 id="appenders">Appenders</h2>
<p>A n appender is an object that persists your log messages someplace. In
the table below a list of the appenders provided by log4net.</p>
<p>Appender</p>
<p>Description</p>
<p>AdoNetAppender</p>
<p>Appender that logs to a database.</p>
<p>AnsiColorTerminalAppender</p>
<p>Appends logging events to the terminal using ANSI color escape
sequences.</p>
<p>AspNetTraceAppender</p>
<p>Appends log events to the ASP.NET TraceContext system.</p>
<p>BufferingForwardingAppender</p>
<p>Buffers events and then forwards them to attached appenders.</p>
<p>ColoredConsoleAppender</p>
<p>Appends logging events to the console colored.</p>
<p>ConsoleAppender</p>
<p>Appends logging events to the console.</p>
<p>DebugAppender</p>
<p>Appends log events to the Debug system.</p>
<p>EventLogAppender</p>
<p>Writes events to the system event log.</p>
<p>ForwardingAppender</p>
<p>This appender forwards logging events to attached appenders.</p>
<p>FileAppender</p>
<p>Appends logging events to a file.</p>
<p>LocalSyslogAppender</p>
<p>Logs events to a local syslog service.</p>
<p>MemoryAppender</p>
<p>Stores logging events in an array.</p>
<p>NetSendAppender</p>
<p>Logs entries by sending network messages using the NetMessageBufferSend
native function.</p>
<p>OutputDebugStringAppender</p>
<p>Appends log events to the OutputDebugString system.</p>
<p>RemoteSyslogAppender</p>
<p>Logs events to a remote syslog daemon.</p>
<p>RemotingAppender</p>
<p>Delivers logging events to a remote logging sink.</p>
<p>RollingFileAppender</p>
<p>Appender that rolls log files based on size or date or both.</p>
<p>SmtpAppender</p>
<p>Send an e-mail when a specific logging event occurs, typically on errors
or fatal errors.</p>
<p>SmtpPickupDirAppender</p>
<p>Send an email when a specific logging event occurs, typically on errors
or fatal errors. Rather than sending via smtp it writes a file that
another service, such as the IIS SMTP agent, can use to manage sending
the messages.</p>
<p>TelnetAppender</p>
<p>Appender that allows clients to connect via Telnet to receive log
messages.</p>
<p>TraceAppender</p>
<p>Appends log events to the Trace system.</p>
<p>UdpAppender</p>
<p>Sends logging events as connectionless UDP datagrams to a remote host or
multicast using the UdpClient class.</p>
<h5 id="fileappender-and-rollingfileappender">FileAppender and RollingFileAppender</h5>
<p>These appenders write log messages to files. A typical configuration for
the FileAppender might l ook like this:</p>
<pre><code>   1:  &lt;appender name=&quot;FileAppender&quot; type=&quot;log4net.Appender.FileAppender&quot;&gt;  




   2:      &lt;file value=&quot;log.txt&quot; /&gt;  




   3:      &lt;appendToFile value=&quot;true&quot; /&gt;  




   4:      &lt;encoding value=&quot;utf-8&quot; /&gt;  




   5:      &lt;layout type=&quot;log4net.Layout.SimpleLayout&quot; /&gt;  




   6:  &lt;/appender&gt;  
</code></pre>
<p>Configuration attributes and its description are:</p>
<ul>
<li><strong>file</strong>: the full or relative path to the log file;</li>
<li><strong>appendToFile</strong>: boolean indicating whether the log file should be
appended (true) or overwritten (false).  If false, the file
overwrite occurs during log4net initialization.  If unspecified, the
log file is appended;</li>
<li><strong>immediateFlush</strong>: boolean indicating whether to flush the log file
TextWriter after each log message is written.  The default is true
(flush each message after its written);</li>
<li><strong>lockingModel</strong>: allows control over the log file locking
strategy.  This can be either
&ldquo;log4net.Appender.FileAppender+MinimalLock&rdquo; to allow for loose file
locking or &ldquo;log4net.Appender.FileAppender+ExclusiveLock&rdquo; to lock the
file during program execution. </li>
</ul>
<p>Keep in mind that the log file managed by FileAppender will be allowed
to grow without bounds. The RollingFileAppender provides basic log file
management, configurable size- or date-boxing of the log file, and
limited rolling backups of the log file.</p>
<pre><code>   1:  &lt;appender name=&quot;RollingFileAppender&quot; type=&quot;log4net.Appender.RollingFileAppender&quot;&gt;  




   2:      &lt;file value=&quot;log-file.txt&quot; /&gt;  




   3:      &lt;appendToFile value=&quot;true&quot; /&gt;  




   4:      &lt;rollingStyle value=&quot;Size&quot; /&gt;  




   5:      &lt;maxSizeRollBackups value=&quot;10&quot; /&gt;  




   6:      &lt;maximumFileSize value=&quot;1MB&quot; /&gt;  




   7:      &lt;staticLogFileName value=&quot;true&quot; /&gt;  




   8:      &lt;layout type=&quot;log4net.Layout.SimpleLayout&quot; /&gt;  




   9:  &lt;/appender&gt;
</code></pre>
<p>Configuration attributes and its description are:</p>
<ul>
<li>
<p><strong>rollingStyle</strong>: this controls how log files are &ldquo;rolled,&rdquo; and can
be one of the following values:</p>
<ul>
<li><strong>Once</strong>: the log file is rolled every time log4net is
initialized (typically at application startup);</li>
<li><strong>Size</strong>: the log file is rolled once it breaches a certain
size;</li>
<li><strong>Date</strong>: the log file is rolled based on the current date;</li>
<li><strong>Composite</strong>: the log file is rolled based on size constraints
and the current date;</li>
</ul>
</li>
<li>
<p><strong>maximumFileSize</strong>: the size cap on the log file.  This is an
expression of size in the form of &ldquo;#(KB|MB|GB)&quot;.  For instance,
&ldquo;100KB&rdquo; or &ldquo;10MB&rdquo;;</p>
</li>
<li>
<p><strong>maxSizeRollBackups</strong>: the maximum number of rolled log file
backups to maintain when rollingStyle is SIZE; when rollingStyle is
COMPOSITE, this indicates the maximum number of roll-offs maintained
<em>per day</em>; this property has no effect when rollingStyle is ONCE or
DATE;</p>
</li>
<li>
<p><strong>datePattern</strong>: the date pattern used to roll files based on date. 
The value of this parameter needs to adhere to the format used by
the SimpleDateFormatter class;</p>
</li>
<li>
<p><strong>staticLogFileName</strong>: a bit of a misnomer - when true this setting
indicates whether log4net should actively write logs to the
configured file (log-file.txt in our example configuration) and
maintain rolling backups by copy.  When false, this setting
indicates that log4net will actively log to the latest roll-off file
(e.g., log-file1.txt, log-file2.txt, log-file3.txt, etc);</p>
</li>
<li>
<p><strong>countDirection</strong>: indicates how roll-off file numbering is
managed.  When this parameter is &gt;= 0, the newest log file will
have the largest number; e.g., log-file.txt.5 will be newer than
log-file.txt.4.  When countDirection &lt; 0, the newest log file
will have the lowest number; e.g., log-file.txt.1 will be newer than
log-file.txt.2.  If unspecified, countDirection defaults to (-1);</p>
</li>
</ul>
<p>Keep in mind that when using a file appender, the user running the
logging process must have rights to create and/or modify the log file in
order for log messages to be written properly.  In addition, log4net
will create the log file if it does not exist, but it will not create
directories in the log file path that do not already exist.  If log4net
encounters a problem initializing the file appender (e.g., it cannot
create the log file for security reasons), the log file will not be
written but your application will continue to execute normally.</p>
<h5 id="using-multiple-appenders">Using multiple appenders</h5>
<p>You can use multiple appenders by specifying each appender you need
under the root logger.</p>
<h2 id="layouts-and-patterns">Layouts and patterns</h2>
<p>A layout is just a template for your log messages.  Layouts are
specified per-appender, and you can specify only one layout for an
appender:</p>
<pre><code>   1:  &lt;appender name=&quot;ColoredConsoleAppender&quot; type=&quot;log4net.Appender.ColoredConsoleAppender&quot;&gt;  




   2:      &lt;layout type=&quot;log4n
et.Layout.SimpleLayout&quot; /&gt;  




   3:  &lt;/appender&gt;  
</code></pre>
<p>The PatternLayout allows you to specify a printf-style template for your
log entries using a &ldquo;conversion pattern,&rdquo; and gives you the opportunity
to decorate each entry with some valuable instance data. For instance,
this configuration:</p>
<pre><code>   1:  &lt;appender name=&quot;ColoredConsoleAppender&quot; type=&quot;log4net.Appender.ColoredConsoleAppender&quot;&gt;  




   2:      &lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&gt;  




   3:          &lt;conversionPattern value=&quot;%date [%thread] %-5level %logger - %message%newline&quot; /&gt;  




   4:      &lt;/layout&gt;  




   5:  &lt;/appender&gt;  
</code></pre>
<p>produces a log that appears like so:</p>
<p><a href="http://lh3.ggpht.com/-veh4_pqN5wM/TpuXa2f4jdI/AAAAAAAAAIg/in7y2Exwnw4/s1600-h/log4net45.jpg"><!-- raw HTML omitted --></a></p>
<p>The conversion pattern string can include literal text and the following
format expressions:</p>
<p><strong>expression</strong></p>
<p><strong>value</strong></p>
<p>%appdomain</p>
<p>the friendly name of the appdomain from which the log entry was made</p>
<p>%date</p>
<p>the local datetime when the log entry was made</p>
<p>%exception</p>
<p>a formatted form of t he exception object in the log entry, if the entry
contains an exception; otherwise, this format expression adds nothing to
the log entry</p>
<p>%file</p>
<p>the file name from which the log entry was made; note that using %file
has a significant performance impact and I don&rsquo;t recommend using it</p>
<p>%identity</p>
<p>the user name of the active user logging the entry; this one is less
reliable than %username; note that using %identity has a significant
performance impact and I don&rsquo;t recommend using it</p>
<p>%level</p>
<p>the severity level of the log entry (DEBUG,INFO, etc)</p>
<p>%line</p>
<p>the source code line number from which the log entry was made; slow</p>
<p>%location</p>
<p>some rudimentary call stack information, including file name and line
number at which the log entry was made; using</p>
<p>%logger</p>
<p>the name of the logger making the entry; more on this in a bit</p>
<p>%method</p>
<p>the name of the method in which the log entry was made; also slow</p>
<p>%message</p>
<p>the log message itself (don&rsquo;t forget this part!)</p>
<p>%newline</p>
<p>the value of Environment.NewLine</p>
<p>%timestamp</p>
<p>the milliseconds between the start of the application and the time the
log entry was made</p>
<p>%type</p>
<p>the full typename of the object from which the log entry was made</p>
<p>%username</p>
<p>the Windows identity of user making the log entry; slow</p>
<p>%utcdate</p>
<p>the UTC datetime when the log entry was made</p>
<p>%%</p>
<p>a percent sign (%)</p>
<p>A common usage of the %logger expression is to identify the source class
in the log entries. Give the class name to the logger like:</p>
<p>private static log4net.ILog Log = log4net.LogManager.GetLogger(
System.Reflection.MethodBase.GetCurrentMethod().DeclaringType ); </p>
<p>and the output will be something like:</p>
<p>ConsoleApplication1.Program [INFO]- this is an info message</p>
<p>Using this technique can help you control logging concerns of your
objects. For example, add a new class “MyClass” to your
ConsoleApplication and use the above approach in declaring your loggers.
Add the following after the &lt;root&gt; section in your app.config :</p>
<pre><code>   1:  &lt;logger name=&quot;ConsoleApplication1&quot;&gt;  




   2:        &lt;level value=&quot;ALL&quot; /&gt;  




   3:        &lt;appender-ref ref=&quot;FileAppender&quot; /&gt;  




   4:  &lt;/logger&gt;  




   5:  &lt;logger name=&quot;ConsoleApplication1.Program&quot;&gt;  




   6:        &lt;level value=&quot;ALL&quot; /&gt;  




   7:        &lt;appender-ref ref=&quot;ConsoleAppender&quot; /&gt;  




   8:  &lt;/logger&gt;  




   9:  &lt;logger name=&quot;ConsoleApplication1.MyClass&quot;&gt;  




  10:        &lt;level value=&quot;ALL&quot; /&gt;  




  11:  &lt;/logger&gt;  
</code></pre>
<p>This way, the console output will display only the log statements from
the Program class, the log file will contain the log statements from
both Program class and MyClass class. Although MyClass doesn’t have an
appender associated with it, the container namespace does and that
appender who processes MyClass log statements. If you changed the level
value to “OFF” for ConsoleApplication1.MyClass, the log file will not
contain log statements from MyClass. When applying the previous
technique keep into consideration the following:</p>
<ul>
<li>Appenders accumulate through the hierarchy: if both the Program
class and ConsoleApplication1 namespace are each configured to
append to the console, any log from the Program class will show up
twice in the console (once for the class logger and once for the
namespace logger).</li>
<li>Specific logger levels deeper in the hierarchy overcome the general
levels : if the Program class logging level is set to ALL and the
ConsoleApplication1 namespace logging level is set to OFF, logs from
the program class are still written to the appenders configured for
ConsoleApplication1.</li>
</ul>
<h4 id="log-event-context">Log event context</h4>
<p>Beside the expressions mentioned above, sometimes you need to log
context information. Modify your console application to look so:</p>
<pre><code>   1:  using System;




   2:  namespace ConsoleApplication1




   3:  {




   4:      class Program




   5:      {




   6:          private static log4net.ILog log = log4net.LogManager.GetLogger(System.Reflection.MethodBase.GetCurrentMethod().DeclaringType);




   7:          static void Main(string[] args)




   8:          {




   9:              log4net.Config.XmlConfigurator.Configure();




  10:              log4net.ThreadContext.Properties[&quot;myContext&quot;] = &quot;Logging from Main&quot;;




  11:              log.Info(&quot;Just info.&quot;);




  12:              Console.ReadLine();  




  13:          }




  14:      }




  15:  }
</code></pre>
<p>Now update the app.config to look like:</p>
<pre><code>   1:  &lt;?xml version=&quot;1.0&quot; enc
oding=&quot;utf-8&quot; ?&gt;




   2:  &lt;configuration&gt;




   3:    &lt;configSections&gt;




   4:      &lt;section name=&quot;log4net&quot;




   5:        type=&quot;log4net.Config.Log4NetConfigurationSectionHandler, log4net&quot;/&gt;




   6:    &lt;/configSections&gt;




   7:   




   8:    &lt;log4net&gt;




   9:   




  10:      &lt;appender name=&quot;ConsoleAppender&quot; type=&quot;log4net.Appender.ConsoleAppender&quot;&gt;




  11:        &lt;layout type=&quot;log4net.Layout.PatternLayout&quot;&gt;




  12:          &lt;conversionPattern value=&quot;%logger (%property{myContext}) [%level]- %message%newline&quot; /&gt;




  13:        &lt;/layout&gt;




  14:      &lt;/appender&gt;




  15:   




  16:      &lt;root&gt;




  17:        &lt;level value=&quot;ALL&quot; /&gt;




  18:        &lt;appender-ref ref=&quot;ConsoleAppender&quot; /&gt;




  19:      &lt;/root&gt;




  20:    &lt;/log4net&gt;




  21:  &lt;/configuration&gt;
</code></pre>
<p>Compile and run, you will got a log statement similar to:</p>
<p>ConsoleApplication1.Program (Logging from Main) [INFO]- Just info.</p>
<p>What we did here is that we added a property “myContext” to the
ThreadContext static class and assigned a simple string value. This prop
erty processed by the appender through the %property{myContext}
expression in the layout conversion pattern.</p>
<p>There are three hierarchy logging contexts available in log4net, where
properties in the more granular contexts override property values in
less granular contexts.</p>
<p>Context</p>
<p>Description</p>
<p><strong>log4net.GlobalContext</strong></p>
<p>A global context shared across all application threads and app domains.
If two threads set the same property on the GlobalContext, one value
will overwrite the other.</p>
<p><strong>log4net.ThreadContext</strong></p>
<p>Any properties set in this context are scoped to the calling thread. In
other words, in this context two threads can set the same property to
different values without stomping on each other.</p>
<p><strong>log4net.ThreadLogicalContext</strong></p>
<p>This context behaves similarly to the ThreadContext, except that the
scope is defined by logical thread boundaries. I&rsquo;ll be honest and say
that I&rsquo;ve never used the ThreadLogicalContext in my career, but if
you&rsquo;re working with a custom thread pool algorithm or hosting the CLR,
you may find some use for this one.</p>
<h5 id="calculated-context-values">Calculated context values</h5>
<p>Context property values don&rsquo;t have to be strings. You can set the value
of a context property to any object reference; then the object&rsquo;s
ToString can be used to obtain the needed context property when a
logging event occurs. This technique could be used to log whatever state
you want at the time of each logging event.</p>
<h5 id="threadcontext-stacks">ThreadContext Stacks</h5>
<p>ThreadContext and ThreadLogicalContext can store property values in
stacks available via the Stacks static property of each class. Pushing a
property value onto a stack returns an IDisposable that, when disposed,
pops the property value off of the stack.  The logging output reflects
the state of the context stack at each logging event; the stack is
represented as a space-delimited list, with newer items appearing later
in the list. Its like printing the current call stack in every log
statement. check this example:</p>
<pre><code>   1:  using System;




   2:  namespace ConsoleApplication1




   3:  {




   4:      class Program




   5:      {




   6:          private static log4net.ILog log = log4net.LogManager.GetLogger(System.Reflection.MethodBase.GetCurrentMethod().DeclaringType);




   7:          static void Main(string[] args)




   8:          {




   9:              log4net.Config.XmlConfigurator.Configure();




  10:              using (log4net.ThreadContext.Stacks[&quot;myContext&quot;].Push(&quot;Main&quot;))




  11:              {




  12:                  FirstAction();




  13:                  SecondAction();




  14:              }




  15:              Console.ReadLine();  




  16:          }




  17:   




  18:          static void FirstAction()




  19:          {




  20:              using (log4net.ThreadContext.Stacks[&quot;myContext&quot;].Push(&quot;FirstAction&quot;))




  21:              {




  22:                  UtilityRoutine();




  23:              }            




  24:          }




  25:   




  26:          static void SecondAction()




  27:          {




  28:              using (log4net.ThreadContext.Stacks[&quot;myContext&quot;].Push(&quot;SecondAction&quot;))




  29:              {




  30:                  UtilityRoutine();




  31:                  FirstAction();




  32:              }




  33:          }




  34:   




  35:          static void UtilityRoutine()




  36:          {




  37:              using (log4net.ThreadContext.Stacks[&quot;myContext&quot;].Push(&quot;UtilityRoutine&quot;))




  38:              {




  39:                  log.Info(&quot;this is an info message&quot;);




  40:              }




  41:          }  




  42:      }




  43:  }
</code></pre>
<p>Compile and run, you will get these log messages:</p>
<p>ConsoleApplication1.Program (Main FirstAction UtilityRoutine) [INFO]-
this is an info message</p>
<p>ConsoleApplication1.Program (Main SecondAction UtilityRoutine) [INFO]-
this is an info message</p>
<p>ConsoleApplication1.Program (Main SecondAction FirstAction
UtilityRoutine) [INFO]- this is an info message</p>
<h2 id="heading"> </h2>
<h2 id="filters">Filters</h2>
<p>Filters are applied to individual appenders via the log4net
configuration, and they help the appender determine whether a log event
should be processed by the appender. The following configuration defines
two file appenders, each with a unique filter applied:</p>
<pre><code>   1:  &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;  




   2:  &lt;configuration&gt;  




   3:    &lt;configSections&gt;  




   4:      &lt;section name=&quot;log4net&quot; type=&quot;log4net.Config.Log4NetConfigurationSectionHandler, log4net&quot;/&gt;  




   5:    &lt;/configSections&gt;  




   6:    &lt;log4net&gt;  




   7:      &lt;appender name=&quot;LogFileAppender&quot; type=&quot;log4net.Appender.FileAppender&quot;&gt;  




   8:        &lt;file value=&quot;log.txt&quot; /&gt;  




   9:        &lt;filter type=&quot;log4net.Filter.LevelRangeFilter&quot;&gt;  




  10:          &lt;levelMin value=&quot;DEBUG&quot; /&gt;  




  11:          &lt;levelMax value=&quot;WARN&quot; /&gt;  




  12:        &lt;/filter&gt;  




  13:        &lt;layout type=&quot;log4net.Layout.SimpleLayout&quot; /&gt;  




  14:      &lt;/appender&gt;  




  15:      &lt;appender name=&quot;ErrorFileAppender&quot; type=&quot;log4net.Appender.FileAppender&quot;&gt;  




  16:        &lt;file value=&quot;errors.txt&quot; /&gt;  




  17:        &lt;filter type=&quot;log4net.Filter.LevelRangeFilter&quot;&gt;  




  18:          &lt;levelMin value=&quot;ERROR&quot; /&gt;  




  19:          &lt;levelMax value=&quot;FATAL&quot; /&gt;  




  20:        &lt;/filter&gt;  




  21:        &lt;layout type=&quot;log4net.Layout.SimpleLayout&quot; /&gt;  




  22:      &lt;/appender&gt;  




  23:      &lt;root&gt;  




  24:        &lt;level value=&quot;DEBUG&quot; /&gt;  




  25:        &lt;appender-ref ref=&quot;LogFileAppender&quot; /&gt;  




  26:        &lt;appender-ref ref=&quot;ErrorFileAppender&quot; /&gt;  




  27:      &lt;/root&gt;  




  28:    &lt;/log4net&gt;  




  29:  &lt;/configuration&gt; 
</code></pre>
<p>The filter on the first appender will log statements with levels DEBUG,
INFO, and WARN; the filter on the second appender will log statements
with levels ERROR and FATAL. There are many filters available in
log4net, we will review them quickly.</p>
<p><strong>log4net.Filter.LoggerMatchFilter</strong> Filters log events based on the
name of the logger object from which they are emitted. This filter can
be configured using the following properties:</p>
<ul>
<li><!-- raw HTML omitted -->loggerToMatch<!-- raw HTML omitted -->: a string value to
match against the message&rsquo;s logger name.  The match is made using
the String.StartsWith method;</li>
<li><!-- raw HTML omitted -->acceptOnMatch<!-- raw HTML omitted -->: a boolean value
indicating whether a matching logger name results in accepting the
message (true) or rejecting it (false).  This defaults to true,
meaning that only matching logger names will be allowed into the
appender.</li>
</ul>
<p><strong>log4net.Filter.LevelMatchFilter</strong> Filters log statements that match
(or don’t match) a specific logging level. This filter can be configured
using the following properties:</p>
<ul>
<li><!-- raw HTML omitted -->levelToMatch<!-- raw HTML omitted -->: the log level to
match - either DEBUG, INFO, WARN, ERROR, or FATAL;</li>
<li><!-- raw HTML omitted -->acceptOnMatch<!-- raw HTML omitted -->: a boolean value
indicating whether to accept log levels matching the levelToMatch
property (true), or reject log levels matching the levelToMatch
property (false).  Defaults to true.</li>
</ul>
<p><strong>log4net.Filter.LevelRangeFilter</strong> Similar to the LevelMatchFilter,
except that instead of filtering a single log level, this filters on an
inclusive range of contiguous levels. This filter can be configured
using the following properties:</p>
<ul>
<li><!-- raw HTML omitted -->levelMin<!-- raw HTML omitted -->: the minimum log level to
match - either DEBUG, INFO, WARN, ERROR, or FATAL;</li>
<li><!-- raw HTML omitted -->levelMax<!-- raw HTML omitted -->: the minimum log level to
match - either DEBUG, INFO, WARN, ERROR, or FATAL;</li>
<li><!-- raw HTML omitted -->acceptOnMatch<!-- raw HTML omitted -->: a boolean value
indicating whether to accept log levels matching the levelToMatch
property (true), or to punt filtering to the next filter in the
chain (false).  Defaults to true.  Note that any log level outside
of the [levelMin, levelMax] range is denied by this filter.</li>
</ul>
<p><strong>log4net.Filter.StringMatchFilter</strong> Filters log events based on a
string or regular expression match against the log message. This filter
can be configured using the following properties:</p>
<ul>
<li><!-- raw HTML omitted -->regexToMatch<!-- raw HTML omitted -->: a regular expression to
match against the log message.  Note this regex is created with the
Compiled option enabled for performance;</li>
<li><!-- raw HTML omitted -->stringToMatch<!-- raw HTML omitted -->: a static string to
match against the log message.  The match is made using the
String.IndexOf method to see if the static string exists in the log
message, which is a case-sensitive search.</li>
<li><!-- raw HTML omitted -->acceptOnMatch<!-- raw HTML omitted -->: a boolean value
indicating whether to accept log messages matching the string or
regex (true), or to deny log messages matching the string or regex
(false).  Defaults to true. </li>
</ul>
<p><strong>log4net.Filter.PropertyFilter</strong> Filters log events based on a value or
regular expression match against a specific context property.</p>
<ul>
<li><!-- raw HTML omitted -->key<!-- raw HTML omitted -->: the name of the property value
to match;</li>
<li><!-- raw HTML omitted -->regexToMatch<!-- raw HTML omitted -->: a regular expression to
match against the specified property value.  Note this regex is
created with the Compiled option enabled for performance;</li>
<li><!-- raw HTML omitted -->acceptOnMatch<!-- raw HTML omitted -->: a boolean value
indicating whether to accept messages with a property value matching
the string or regex (true), or to deny messages with a property
value matching the string or regex (false).  Defaults to true.</li>
</ul>
<p><strong>log4net.Filter.DenyAllFilter</strong> This filter simply denies all
filtering.  When this is used, it&rsquo;s always at the end of a filter chain
to block unwanted log messages from the appender.</p>
<h2 id="lossy-logging">Lossy logging</h2>
<p>If you want comprehensive log to be there in case of errors but you
worry about the resources consumed by logging, you might use lossy
logging.  Lossy logging gives the best of both worlds, under normal
operation your application will not log any messages; however, if your
application logs an error, a small batch of messages leading up to the
error is placed into the log, giving you the error and a snapshot of
system activity just before it happened.</p>
<p>Lets modify our code to be like:</p>
<pre><code>   1:  using System;




   2:  namespace ConsoleApplication1




   3:  {




   4:      class Program




   5:      {




   6:          static log4net.ILog Log = log4net.LogManager.GetLogger(System.Reflection.MethodBase.GetCurrentMethod().DeclaringType);




   7:          static void Main( string[] args )




   8:          {




   9:              log4net.Config.XmlConfigurator.Configure();




  10:              for( int i = 0; i &lt; 100; ++i )




  11:              {




  12:                  Log.DebugFormat( &quot;this is debug msg #{0}&quot;, i );




  13:              }                




  14:              Log.Error( &quot;error: an error occurred!&quot; );           




  15:  
          Log.Warn( &quot;warning: you've been warned&quot; );




  16:              




  17:              Console.ReadLine();




  18:          }




  19:      }




  20:  }
</code></pre>
<p>Let&rsquo;s modify our app.config to look like:</p>
<pre><code>   1:  &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;




   2:  &lt;configuration&gt;




   3:    &lt;configSections&gt;




   4:      &lt;section name=&quot;log4net&quot; type=&quot;log4net.Config.Log4NetConfigurationSectionHandler, log4net&quot;/&gt;




   5:    &lt;/configSections&gt;




   6:   




   7:    &lt;log4net&gt;




   8:      &lt;appender name=&quot;ConsoleAppender&quot; type=&quot;log4net.Appender.ConsoleAppender&quot;&gt;




   9:        &lt;layout type=&quot;log4net.Layout.SimpleLayout&quot; /&gt;




  10:      &lt;/appender&gt;




  11:   




  12:      &lt;appender name=&quot;LossyConsoleAppender&quot; type=&quot;log4net.Appender.BufferingForwardingAppender&quot;&gt;




  13:        &lt;bufferSize value=&quot;20&quot; /&gt;




  14:        &lt;lossy value=&quot;true&quot;/&gt;




  15:        &lt;evaluator type=&quot;log4net.Core.LevelEvaluator&quot;&gt;




  16:          &lt;threshold value=&quot;ERROR&quot; /&gt;




  17:        &lt;/evaluator&gt;




  18:        &lt;appender-ref ref=&quot;ConsoleAppender&quot; /&gt;




  19:      &lt;/appender&gt;




  20:   




  21:      &lt;root&gt;




  22:        &lt;level value=&quot;DEBUG&quot; /&gt;




  23:        &lt;appender-ref ref=&quot;LossyConsoleAppender&quot; /&gt;




  24:      &lt;/root&gt;




  25:    &lt;/log4net&gt;




  26:  &lt;/configuration&gt;
</code></pre>
<p>Compile and run, you will see output like:</p>
<p><a href="http://lh4.ggpht.com/-N8_s5KkwyD8/TpuXbr5iCLI/AAAAAAAAAIw/XQ4STy5OuAM/s1600-h/log4net5%25255B1%25255D.jpg"><!-- raw HTML omitted --></a></p>
<p>The logging configuration defines two appenders, one very generic
Console appender and a BufferingForwardingAppender.  As the name
implies, the latter appender buffers log messages and forwards them in
batches to one or more other appenders.  You can probably tell from the
configuration XML that I&rsquo;ve set this appender up with a 20-message
buffer.  The lossy and evaluator parameters work together to define when
the log message buffer is forwarded to the &ldquo;base&rdquo; appender.</p>
<p>The program issues a total of 102 log messages (100 DEBUG, one ERROR,
and one WARN), but the console only contains 20 messages (19 DEBUG and 1
ERROR).  So what happened to the other 82 DEBUG and WARN messages?</p>
<p>When the BufferingForwardingAppender&rsquo;s lossy property is enabled, the
appender will buffer log messages without forwarding them.  If the
buffer fills up, the oldest messages are dropped from the buffer to make
room for the new messages. </p>
<p>The evaluator property determines when the appender forwards the
messages from the buffer to its base appenders.  There is only one
evaluator defined in log4net - the LevelEvaluator.  The LevelEvaluator
triggers the forward when a log message is received that meets or
exceeds the configured threshold.  The example above is configured so
that an ERROR message triggers the appender to forward its buffer to the
ConsoleAppender.</p>
<p>Lossy Appender Types log4net provides the following appenders that can
operate “lossy” :</p>
<p>log4net.Appender.AdoNetAppender</p>
<p>log4net.Appender.RemotingAppender</p>
<p>log4net.Appender.SmtpAppender</p>
<p>log4net.Appender.SmtpPickupDirAppender</p>
<p>log4net.Appender.BufferingForwardingAppender</p>
<h5 id="configuring-log4net-programmatically">Configuring log4net Programmatically</h5>
<p>Sometimes we are in the mood to code as quickly as possible without
getting into configuration files. Normally, that happens when we are
trying to test something. In that case, you have another way to do the
configuration. All of the long configuration files that we saw in the
previous section can be defined programmatically using a few lines of
code. See the following code:</p>
<pre><code>   1:  // using a FileAppender with a PatternLayout




   2:  log4net.Config.BasicConfigurator.Configure( new log4net.Appender.FileAppender(new log4net.Layout.PatternLayout(&quot;%d [%t]%-5p %c [%x] &amp;lt;%X{auth}&amp;gt; - %m%n&quot;),&quot;testfile.log&quot;));




   3:   




   4:  // using a FileAppender with an XMLLayout




   5:  log4net.Config.BasicConfigurator.Configure( new log4net.Appender.FileAppender(new log4net.Layout.XMLLayout(),&quot;testfile.xml&quot;));




   6:   




   7:  // using a ConsoleAppender with a PatternLayout




   8:  log4net.Config.BasicConfigurator.Configure( new log4net.Appender.ConsoleAppender(new log4net.Layout.PatternLayout(&quot;%d [%t] %-5p %c [%x] &amp;lt;%X{abc}&amp;gt; - %m%n&quot;)));




   9:   




  10:  // using a ConsoleAppender with a SimpleLayout




  11:  log4net.Config.BasicConfigurator.Configure( new log4net.Appender.ConsoleAppender(new log4net.Layout.SimpleLayout()));
</code></pre>
<p>You can see that while it is easy to code here, you can&rsquo;t configure
settings for individual loggers. All of the settings that are defined
here are applied to the root logger.</p>
<h2 id="log4net-best-practices">Log4net Best Practices</h2>
<p>1- Use a unique logger object for each type in your application and give
it the class name. Like so:</p>
<p><code>static</code>
<code>log4net.ILog Log = log4net.LogManager.GetLogger(``System.Reflection.MethodBase.GetCurrentMethod().DeclaringType``);</code></p>
<p>2- Whenever you catch an exception, log it.  Even if you just plan to
throw it again, log it.  In addition, log4net knows how to format
Exception objects, so don&rsquo;t try and build your own string from the
exception data, just pass the exception to the logging statement. Like
So:</p>
<p><code>Log.Error(``&quot;An exception raised due to XYZ&quot;``, ``e``);</code></p>
<p>3- Log to mark the activity and steps of your code.</p>
<p>4- Check for null references before logging any property. Logging code
is code, and it should be treated the same way.</p>
<p>5- If an argument to the log method is expensive to obtain, be sure to
guard your log statement with a check of the appropriate Is*Enabled
property</p>
<p><code>if``( Log.IsDebugEnabled )``{ /* log statement */ }</code></p>
<p>6- Before an object calls on a shared dependency, consider pushing a tag
onto the log context stack.  This will allow you to determine the caller
of the shared code that logged a particular message.</p>
<p>7- Whenever you use a formatted log statement, surround the format
argument placeholders (the {}&lsquo;s) with brackets or parentheses. This will
mark the areas in each log message. This make the log scan a bit easier
and makes empty or null formatting arguments more obvious. </p>
<h2 id="suggested-logging-levels">Suggested logging levels</h2>
<p><strong>INFO Level</strong></p>
<ul>
<li>The start and end of the method</li>
<li>The start and end of any major loops</li>
<li>The start of any major case/switch statements</li>
</ul>
<p><strong>DEBUG Level</strong></p>
<ul>
<li>Any parameters passed into the method</li>
<li>Any row counts from result sets I retrieve</li>
<li>Any datarows that may contain suspicious data when being passed down
to the method</li>
<li>Any &ldquo;generated&rdquo; file paths, connection strings, or other values that
could get mungled up when being &ldquo;pieced together&rdquo; by the
environment.</li>
</ul>
<p><strong>ERROR Level</strong></p>
<ul>
<li>Handled exceptions</li>
<li>Invalid login attempts (if security is an issue)</li>
<li>Bad data that I have intercepted forreporting</li>
</ul>
<p><strong>FATAL Level</strong></p>
<ul>
<li>Unhandled exceptions.</li>
</ul>
<p> </p>
<p>In this post I tried to cover as much as possible about logging using
log4net. Although logging is extremely useful, keep in mind that it is
not free, it consumes resources and the more you log the less you can
find. So be careful, and Good Luck.</p>

              <hr>
              <div class="related-posts">
                <h5>Related Posts</h5>
                
              </div>
            </div>
          </div>
          <hr>
        <div class="disqus">
  <div id="disqus_thread"></div>
  <script type="text/javascript">

    (function() {
      
      
      if (window.location.hostname == "localhost")
        return;

      var disqus_shortname = '';
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  <a href="http://disqus.com/" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>
        </div>
      </div>
      
    </div>

    
    <footer>
  <div id="footer">
    <div class="container">
      <p class="text-muted">&copy; All rights reserved. Powered by <a href="https://gohugo.io/">Hugo</a> and
      <a href="http://www.github.com/nurlansu/hugo-sustain/">sustain</a> with ♥</p>
    </div>
  </div>
</footer>
<div class="footer"></div>


<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>

<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
<script src="https://ebeid.github.io/js/docs.min.js"></script>
<script src="https://ebeid.github.io/js/main.js"></script>

<script src="https://ebeid.github.io/js/ie10-viewport-bug-workaround.js"></script>


    
  </body>
</html>
