---
title: An introduction to Microsoft Message Queuing–Part 2
date: '2011-11-22T11:52:00.004-06:00'
author: Ebeid Soliman ElSayed
tags:
- MSMQ
modified_time: '2011-12-01T12:36:07.637-06:00'
blogger_id: tag:blogger.com,1999:blog-59384554657271185.post-5646394697131614938
blogger_orig_url: http://ebeid-soliman.blogspot.com/2011/11/in-previous-post-we-explored-very-basic.html
---

<p>In the <a title="An introduction to Microsoft Message Queuing" href="http://ebeid-soliman.blogspot.com/2011/11/introduction-to-microsoft-message.html" target="_blank">previous post</a>, we explored very basic concepts of MSMQ. We used non-transactional queue to send and receive a message. In this post we will try to dive more into Message Queuing Queues.</p>  <p>Simply, queues are logical containers that Message Queuing uses to store and later forward messages, providing the bases for the loosely coupled aspects of Message Queuing. Queues can be created by applications and by Message Queuing. Queues created by applications or by users in an MMC snap-in are referred to as <em><strong>application queues</strong></em>. Queues created by Message Queuing are referred to as <strong><em>system-generated queues </em></strong>(we will talk about system- generated queues in another post).</p>  <p>Depending on the service provided by the queue, <strong>application queues</strong> can be <u>public</u> or <u>private</u>, and they can be <u>transactional</u> or <u>nontransactional</u>. </p>  <p><strong>Application queues</strong> can play any of the following roles:</p>  <ul>   <li>Destination queues : any queue used to send/receive messages between applications. </li>    <li>Administration queues : used for <em>acknowledgment messages</em> returned by Message Queuing or <em>connector applications</em>. </li>    <li>Response queues : used by receiving applications to return <em>response messages</em> to the sending application. </li>    <li>Report queues : used to store <em>report messages</em> returned by Message Queuing. </li> </ul>  <h5>Destination Queues</h5>  <p>Destination queues are any queue used to send/receive messages between applications. The sending application on computer 1 sends the messages to the queue and the receiving application on computer 2 reads the messages from the queue. Typically, destination queues are located on the same computer as the receiving application in order to minimize network traffic.</p>  <p><strong><u>Public Versus Private Queues</u></strong> The decision to use public or private destination queues depends primarily on whether you want other applications to be able to locate the queues or not. Message Queuing registers private queues locally by storing a description of each queue in a separate file in the local queue storage (LQS) folder on the local computer (the default Lqs folder is %windir%\System32\MSMQ\Storage\Lqs). Also a description of each public queue created on the local computer is also stored locally in a separate file in the Lqs folder.</p>  <p>Adv. of Public Queues:</p>  <ul>   <li>Registered in the directory service, so it can be located by other Message Queuing applications. </li>    <li>Persistent and its registration information can be backed up. </li> </ul>  <p>Adv. of Private Queues:</p>  <ul>   <li>Requires minimal directory service overhead(faster to create, no latency, and no replication) </li>    <li>Can be created and deleted when the <em>directory service</em> is not working </li>    <li>Can be accessed directly by name without query the directory service. </li> </ul>  <p>Div. of Private Queues:</p>  <ul>   <li>It is registered on local computer, so it is properties cannot be obtained by Message Queuing applications running on remote computers. Private queues can be exposed to other applications by making the location of the private queue known to the applications. To distribute the location of a private queue, an application can send the format name of the private queue as the response queue property of a message. </li> </ul>  <p><strong><u>Transactional Versus Nontransactional Queues</u></strong> The decision to use transactional or nontransactional queues is based on whether the applications accessing the queue will be sending and receiving messages within the context of a transaction. So, what is a transaction ? a transaction is to execute a multiple-steps process such that either all or none of the steps will complete. In reality, transactions are handled by rolling back any steps that have already occurred if the entire transaction is not completed successfully. </p>  <p>When sending messages, only transactional queues can accept messages sent in the context of a transaction. These messages are also referred to as transactional messages. In a similar way, nontransactional queues can only accept messages sent outside the context of a transaction. Note that only transactional messages are delivered with exactly-once-delivery (EOD) guarantees.</p>  <p>When receiving messages, only local transactional queues can be accessed within the context of a transaction. The transactional queue must be local to the receiving application. On the other hand, nontransactional queues can be accessed within or outside of a transaction. Also, transactional queues, local or remote, can be accessed outside of a transaction (because we ask it to do less than what it can do).</p>  <p>If you just want to be able to recover lost messages, don’t use transactional queues. You can set the <em>Recoverable</em> property of a every message you sent. Or you can sent the queue property <span><span>DefaultPropertiesToSend.Recoverable</span> <span>to true.</span></span></p>  <h5>Creating a Transactional Queue</h5>  <ul>   <li>Through the snap in : just check the check-box Transactional below the queue name textbox. </li>    <li>Programmatically : just like <span>privateQueue = MessageQueue.Create(".\\Private$\\privateQueue", true);</span> </li> </ul>  <p><span>MessageQueue <span>have a property called</span> Transactional <span>that you can check to ensure that the queue is transactional</span> </span></p>  <p>MSMQ supports two types of transactions: Internal and External.</p>  <h5>Internal Transactions</h5>  <p>Class <span>MessageQueueTransaction <span>can be used to</span> Begin(), Commit(), Abort() <span>the transaction. It also can be passed through</span> Send() <span>and</span> Receive() </span><span>methods to that operation falls under a transaction. The class also exposes a Status property to give the transaction status. Transaction status can be one of:</span></p>  <ul>   <li>Initialized : The transaction has been initialized but not yet started. </li>    <li>Pending : The transaction has been began but not committed or aborted yet. </li>    <li>Committed : The transaction has been committed. </li>    <li>Aborted : The transaction has been aborted. </li> </ul>  <p><strong>Transaction Types</strong> when sending or receiving using MessageQueue class through transactional queues, you could pass one of the values in MessageQueueTransactionType enumeration. This specifies how you would like to interact with the queue. These values are:</p>  <ul>   <li>Single : each queue operation will be doine in a separate internal transaction. </li>    <li>None : enable you to receive a message from a transactional queue, but outside a transaction. It also enables us to send a transactional message to a non-transactional queue. </li>    <li>Automatic : used with external transactions to direct the send or receive operations to use an already existing transaction context. </li> </ul>  <p>Now lets compile these pieces into one example to get sense of what internal transactional queues means.</p><pre class="brush:csharp">using System;<br />using System.Collections.Generic;<br />using System.Linq;<br />using System.Text;<br />using System.Messaging;<br /><br />namespace MSMQ_Demo3<br />{<br /> class Program<br /> {<br />     static void Main(string[] args)<br />     {<br />         MessageQueueTransaction mqTran = new MessageQueueTransaction();<br />         MessageQueue queueA = MessageQueue.Create(".\\Private$\\TranQueueA", true);<br />         MessageQueue queueB = MessageQueue.Create(".\\Private$\\TranQueueB", true);<br />         mqTran.Begin();<br />         try<br />         {<br />             queueA.Send("Message A", "Label A", mqTran );<br />             queueB.Send("Message B", "Label B", mqTran );<br />             mqTran.Commit();<br />         }<br />         catch(Exception ex)<br />         {<br />             mqTran.Abort();<br />             Console.WriteLine(ex.Message);<br />         }             <br /><br />         MessageQueue queueC = new MessageQueue(".\\Private$\\TranQueueA");<br />         MessageQueue queueD = new MessageQueue(".\\Private$\\TranQueueB");<br />         string strMsg = "";<br />         mqTran.Begin();<br />         try<br />         {<br />             Message msg = queueC.Receive(mqTran);<br />             msg.Formatter = new XmlMessageFormatter(new Type[1] { typeof(string) });<br />             strMsg = msg.Body.ToString();<br />             msg = queueD.Receive(mqTran);<br />             msg.Formatter = new XmlMessageFormatter(new Type[1] { typeof(string) });<br />             strMsg += " \n ";<br />             strMsg += msg.Body.ToString();<br />             Console.WriteLine(strMsg);<br />             mqTran.Commit();<br />         }<br />         catch (Exception ex)<br />         {<br />             mqTran.Abort();<br />             Console.WriteLine(ex.Message);<br />         }<br />         Console.WriteLine();<br />     }<br />  <br /> }<br />}<br /><br /></pre><br /><br /><span class="Apple-style-span" style="font-family: Georgia, serif; font-size: 16px; white-space: normal; ">In this example we created two transactional queues, send two messages to them. Then we received these messages. Both the sending and receiving done in a transaction that commits only after the success of all operations. If any errors happened, we abort the whole transaction and rollback all operations done in it.</span><p>In future posts we will talk more about MSQM details.</p>
