---
layout: post
title: Parameterized Test Patterns using Microsoft Pex
date: '2013-05-02T16:08:00.000-05:00'
author: Ebeid Soliman ElSayed
tags:
- Microsoft Pex
- Parameterized Unit Tests
- Unit Tests
- Unit testing
modified_time: '2013-05-02T16:08:18.632-05:00'
blogger_id: tag:blogger.com,1999:blog-59384554657271185.post-8505498433861402798
blogger_orig_url: http://ebeid-soliman.blogspot.com/2013/05/parameterized-test-patterns-using.html
---

<p>We talked before about the difference between unit tests and parameterized unit tests. In this post we will talk about common patterns for writing good parameterized unit tests. Keep in mind that we will use these tests with Microsoft Pex (as an automatic test input generation tool) to get test inputs that trigger all the possible scenarios of the code-under-test. </p> <blockquote> <p>Before anything, let’s clarify what are the questions we want to answer using the parameterized unit tests. There are&nbsp; two core questions:</p> <ul> <li>What are good scenarios (sequences of method calls) to exercise the code-under-test? (<font color="#ff0000">Coverage</font>)  <li>What are good assertions that can be stated easily without re-implementing the algorithm? (<font color="#ff0000">Verification</font>)</li></ul> <p>A parameterized unit test is only useful if it provides answers for both questions: </p> <ul> <li>Without sufficient coverage, i.e. if the scenario is too narrow to reach all the code-under-test, the extent of the test is limited.  <li>Without sufficient verification of the computed results, i.e. if the test does not contain enough assertions, the test does not check that the code is doing the right thing. All it would check for is that the code-under-test does not crash.</li></ul></blockquote> <h3>Test Patterns</h3> <h4>1- Arrange, Act, Assert</h4> <p>The ’AAA’ (Triple-A) is a well-known pattern for writing unit tests. It applies to parameterized unit tests as well. A parameterized unit test using this patter is organized in three sections:</p> <ul> <li><strong>Arrange</strong>: set up the unit under test  <li><strong>Act</strong>: exercise the unit under test, capturing any resulting state  <li><strong>Assert</strong>: verify the behavior through assertions</li></ul> <p>An example of this pattern in a traditional unit test:</p>  <pre class="prettyprint lang-cs"><br />[Test]<br>pubic void AddItem()<br>{<br>      // arrange<br>      var list = new ArrayList();<br>      var item = new object();<br>      // act<br>      list.Add(item);<br>      // assert<br>      Assert.IsTrue(list.Count == 1);<br>}<br /></pre><br /><br /><p>An example of this pattern in a parameterized unit test:</p><br /><br /><pre class="prettyprint lang-cs"><br />[PexMethod]<br>pubic void AddItem(object item)<br>{<br>      // arrange<br>      var list = new ArrayList();<br>      // act<br>      list.Add(item);<br>      // assert<br>      Assert.IsTrue(list.Count == 1);<br>}<br /></pre><br /><br /><h4>2- Assume, Arrange, Act, Assert</h4><br /><p>This pattern is an extension of the first pattern where an Assumption section is added at the beginning. An <strong>assumption</strong> restricts possible test inputs, acting as a filter. A parameterized unit test using this pattern is organized in four sections: </p><br /><ul><br /><li><strong>Assume</strong>: assume preconditions over the test inputs </li><br /><li><strong>Arrange</strong>: set up the unit under test </li><br /><li><strong>Act</strong>: exercise the unit under test, capturing any resulting state </li><br /><li><strong>Assert</strong>: verify the behavior through assertions </li><br /></ul><br /><p>The following example tests that adding an element to any list increments the Count property. We use an assumption to filter out the case where list is a null reference.</p><br /><br /><pre class="prettyprint lang-cs"><br />[PexMethod]<br>void AssumeActAssert(ArrayList list, object item)<br>{<br>     // assume<br>     PexAssume.IsNotNull(list);<br>     // arrange<br>     var count = list.Count;<br>     // act<br>     list.Add(item);<br>     // assert<br>     Assert.IsTrue(list.Count == count + 1);<br>}<br /></pre><br /><br /><h4>3- Parameterized Stubs</h4><br /><br /><p>If the code-under-test already contains many assertion statements that verify its behavior, an effective parameterized unit test might be quite simple in itself, because it can leverage the assertions in the code.</p><br /><br /><pre class="prettyprint lang-cs">[PexMethod] <br>public void Add( [PexAssumeUnderTest]ArrayList list, object item) <br>{ <br> list.Add(item); </pre><br /><br /><p>The attribute PexAssumeUnderTest is a short-hand notation to make sure that the parameter is not null, and has exactly the type indicated by its declaration (not a subtype).</p><br /><br /><br><br /><h4>4- Observed Values</h4>At any point in the parameterized unit test, if you want to log the value of any variable or parameter, just use <br /><pre class="prettyprint lang-cs">PexObserve.ValueForViewing("Variable Name", var_name);</pre><br /><br /><h4>5- Allowed Exceptions</h4><br /><p>Traditional unit test frameworks support the concept of expected exception, where a test case or API call is expected to throw an exception. If the test does not throw the exception or throws an exception that does not match the criteria, the execution fails. The same concept applied to parameterized unit tests. </p><br /><br /><pre class="prettyprint lang-cs">[PexMethod][PexAllowedException(typeof(ArgumentNullException))] <br>void Constructor(string value) <br>{ <br> // throws ArgumentNullException if value is null <br> var myClass = new MyClass(value); <br>}</pre><br /><br /><h4>6- State Relation</h4><br /><p>This pattern applies when an API call causes an internal state change that can be (partially) observed through other API calls. A classic example of such a pattern is the combination of Insert and Contains operation on any collection type:</p><br /><br /><pre class="prettyprint lang-cs"><br />[PexMethod] <br>void InsertContains(stringvalue) <br>{ <br> var list = new List<string>(); <br> list.Add(value); <br> Assert.IsTrue(list.Contains(value)); <br>}<br /></pre><br /><br /><h4>7- Roundtrip</h4><br /><p>This pattern applies to an API that transforms its inputs in a reversible way: When the API has a function <em>f</em> and an inverse function <em>f_1</em>, then it should hold that <em>f_1(f(x))=x</em> for all <em>x</em>. A classic example of such pattern is property setters and getters, where the test fails when the setter rejects a particular argument value.</p><br /><br /><pre class="prettyprint lang-cs"><br />[PexMethod] <br>void PropertyRoundtrip(string value) <br>{ <br> // arrange <br> var target = new MyClass(); <br> <br> // two-way roundtrip <br> target.Name = value;   // calls setter <br> var roundtripped = target.Name; // calls getter <br><br> // assert <br> Assert.AreEqual(value, roundtripped); <br>}<br /></pre><br /><br /><p>Another example is serialization and deserialization of values.</p><br /><pre class="prettyprint lang-cs"><br />[PexMethod] <br>void ToStringParseRoundtrip(int value) <br>{ <br> // two-way roundtrip <br> string s = value.ToString(); <br> int parsed = int.Parse(s); <br><br> // assert Assert.AreEqual(value, parsed); <br>}<br></pre><br /><br /><h4>8- Normalized Roundtrip</h4><br /><p>The Pattern Roundtrip showed how to test a method for which in inverse operation exists. For example, <strong>int.Parse</strong> is the inverse of <strong>int.ToString</strong>. This is not the case in the other direction: <strong>int.ToString</strong> is not exactly the inverse of <strong>int.Parse</strong>, because the parsing ignores whitespace (some kind of data normalization): </p><br /><br /><pre class="prettyprint lang-cs"><br />int.Parse(" 5").ToString() == "5";<br /></pre><br /><br /><p>This pattern is applied when the API has a function <strong>f</strong> and an inverse function <strong>f_1</strong>, then it should hold that <strong>f_1(f(f_1(x)))=f_1(x)</strong> for all <strong>x</strong> where <strong>f_1(x)</strong> is defined.</p><br /><br /><pre class="prettyprint lang-cs"><br />[PexMethod] <br>void ThreeWayRoundtrip(string value) <br>{ <br> // ’hello%20world’ &lt;= ’hello world’ <br> var normalized = Uri.EscapeDataString(value); <br> <br> // ’helloworld’ &lt;= ’hello%20world’ <br> var intermediate = Uri.UnescapeDataString(normalized); <br><br> // ’hello%20world’ &lt;= ’hello world’ <br> var roundtripped = Uri.EscapeDataString(intermediate); <br><br> // assert <br> Assert.AreEqual(normalized, roundtripped); <br>}<br><br /></pre><br /><br /><h4>9- Reachability</h4><br><br /><p>If your test assumptions are so complicated and it is not clear whether there is any test input that fulfills them. You could use <strong>PexAssert.ReachEventually("GoalName")</strong> wherever in your test to make sure that there is at least one input that reach this point in your test. The goal name have to be passed to the <strong>PexAssertReachEventuallyAttribute</strong> constructor. A parameterized unit test fails when Pex does not find a way to reach a goal, indicated by calling the <strong>PexAssert.Reached</strong> method in a parameterized unit test annotated with the <strong>PexAssertReachEventuallyAttribute</strong>.</p><br /><br /><pre class="prettyprint lang-cs"><br />[PexMethod] <br>[PexAssertReachEventually("passed", StopWhenAllReached = true)] <br>public void ParsingSuccesful(string input) <br>{ <br> // complicated parsing code <br> DateTime date; <br> if (DateTime.TryParse(input, out date)) <br> { <br>  // and we want to see at least one case where parsing is successful. <br>  PexAssert.ReachEventually("passed"); <br> } <br>}<br /></pre><br /><br /><p>Multiple goals can be combined in a single parameterized unit test for more advanced scenarios by passing a list of goal identifiers in the constructor of the PexAssertReachEventuallyAttribute. Each goal identifier must be reached and notified in order for the parameterized unit test to succeed.</p><br /><br /><pre class="prettyprint lang-cs"><br />[PexMethod] <br>[PexAssertReachEventually("parsed", "y2k", StopWhenAllReached = true)] <br>public void ParsingSuccesfulWithMoreGoals(string input) <br>{ <br> // complicated parsing code <br> DateTime date;<br> if (DateTime.TryParse(input, out date)) <br> { <br>  // and we want to see at least one case where parsing is successful. <br>  PexAssert.ReachEventually("parsed"); <br> } <br> if (date.Year == 2000) <br> {<br>  // we want to see at least one test with the year 2000 <br>  PexAssert.ReachEventually("y2k"); <br> }<br>}<br /></pre><br /><br /><h4>10- Reachable Implication</h4><br /><br /><p>Implications assert a property when a predicate (condition) is true. Use <strong>PexAssert.ImpliesEventually</strong> to make an implication that should be true and that should be executed at least once. The test have to be annotated with the <strong>PexAssertReachEventuallyAttribute</strong>. A parameterized unit test fails when Pex does not find a way to make the predicate of <strong>PexAssert.ImpliesEventually</strong> evaluates true at least once. </p><br /><br /><pre class="prettyprint lang-cs"><br />[PexMethod] <br>[PexAssertReachEventually] <br>public void ParseImpliesParse(string input) <br>{ <br> bool value; <br> // if TryParse succeeds, Parse should succeed too. Also make sure TryParse succeeds at least once <br> PexAssert.ImpliesEventually( bool.TryParse(input, out value), () =&gt; bool.Parse(input) );<br>}<br /></pre><br /><br /><h4>11- Seed Values to Help Pex</h4><br /><p>A parameterized unit test needs concrete input data to be executed. Pex's role is to automatically generate relevant input data via code analysis. Sometimes it might be desirable or even necessary to provide manually chosen seed values to Pex to guide the automated code exploration. In effect, Pex will fuzz the provided values in ways that cause alternative execution paths to be taken. The <strong>PexArgumentsAttribute</strong> can be used to provide primitive data. Each instance of this attribute gives a list of values that must match the parameter types of the parameterized unit test (and in the same parameters order).<br /></p><br /><br /><pre class="prettyprint lang-cs"><br />[PexMethod]<br />[PexArguments("var i = 0;", 0)]<br />[PexArguments("class Foo {}", 12)]<br />public void ParseTest(string text, int line)<br />{<br /> var parser = new Parser();<br /> parser.SetLine(line);<br /> var node = parser.Parse(text);<br /><br />}<br /></pre><br /><p>Before analyzing the branch conditions in the code, Pex will first execute the parameterized unit test with the provided values. This way, Pex acquires knowledge about the code reachable from a test, and during the subsequence code exploration Pex will try to further increase code coverage by slightly modifying the values to trigger different execution paths. In effect, Pex will <a href="http://en.wikipedia.org/wiki/Fuzz_testing" target="_blank">fuzz</a> the provided values. </p><br /><br /><h4>12- Regression Tests</h4><br /><br /><p>In these tests some we could persist a computed value in the generated test so when the generated test is executed in the future, it verifies that the (possible changed) code-under-test still computes the same value. There are several ways how outputs can be logged. For a single output value, one can use the return value of the parameterized unit test:</p><br /><pre class="prettyprint lang-cs"><br />[PexMethod]<br />public int Add(int a, int b)<br />{<br /> return a + b;<br />}<br /></pre><br /><p>Pex will recursively traverse the observable properties and fields of the value and add assertions in the generated test for each one of them:</p><br /><pre class="prettyprint lang-cs"><br />[Test]<br />[PexGeneratedBy(typeof(Program))]<br />public void Add866()<br />{<br />    int i;<br />    i = this.Add(0, 0);<br />    PexAssert.AreEqual<int>(0, i);<br />}<br /></pre><br /><p>For multiple values, use <strong>out</strong> parameters in the parameterized unit tests</p><br /><pre class="prettyprint lang-cs"><br />[PexMethod]<br />public void Add(int a, int b, out int result)<br />{<br /> result = a + b;<br />}<br /></pre><br /><p>Which Pex will use to generate the following</p><br /><pre class="prettyprint lang-cs"><br />[Test]<br />[PexGeneratedBy(typeof(Program))]<br />public void Add13()<br />{<br />    int i = 0;<br />    this.Add(0, 0, out i);<br />    PexAssert.AreEqual<int>(0, i);<br />}<br /></pre><br /><p>If the number of values might be dynamic, you could log these values using <strong><a href="http://research.microsoft.com/en-us/um/redmond/projects/pex/wiki/PexObserve.html" target="_blank">PexObserve</a>.Value</strong> and observe it later using the <strong><a href="http://research.microsoft.com/en-us/um/redmond/projects/pex/wiki/PexObserve.html" target="_blank">PexObserve</a>.ValueAtEndOfTest</strong> method:</p><br /><pre class="prettyprint lang-cs"><br />[PexMethod]<br />void Add(int a, int b)<br />{<br /> int result = a * b;<br /> PexObserve.Value<int>("result", result);<br />}<br /></pre>  