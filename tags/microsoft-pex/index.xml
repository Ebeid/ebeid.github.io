<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Microsoft Pex on </title>
    <link>http://localhost:1313/tags/microsoft-pex/</link>
    <description>Recent content in Microsoft Pex on </description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Tue, 13 Aug 2013 13:43:00 -0500</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/microsoft-pex/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>How to debug your Pex parameterized unit tests</title>
      <link>http://localhost:1313/2013/08/how-to-debug-your-pex-parameterized.html</link>
      <pubDate>Tue, 13 Aug 2013 13:43:00 -0500</pubDate>
      <guid>http://localhost:1313/2013/08/how-to-debug-your-pex-parameterized.html</guid>
      <description>&lt;p&gt;We talked before about &lt;a href=&#34;http://ebeid-soliman.blogspot.com/2013/04/getting-started-with-microsoft-pex.html&#34; title=&#34;Getting started with Microsoft Pex&#34;&gt;Microsoft Pex&lt;/a&gt;, and &lt;a href=&#34;http://ebeid-soliman.blogspot.com/2013/04/why-pex-choose-these-inputs.html&#34; title=&#34;Why Pex Choose These Inputs&#34;&gt;how it choose the shown inputs&lt;/a&gt;. We then talked more about &lt;a href=&#34;http://ebeid-soliman.blogspot.com/2013/04/microsoft-pex-understanding-assumptions.html&#34; title=&#34;Microsoft Pex: Understanding Assumptions, Assertions, and Test-Case Failures&#34;&gt;building blocks of parameterized unit tests&lt;/a&gt; and its &lt;a href=&#34;http://ebeid-soliman.blogspot.com/2013/05/parameterized-test-patterns-using.html&#34; title=&#34;Parameterized Test Patterns using Microsoft Pex&#34;&gt;patterns&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;What we missed till now is how to debug your parameterized unit tests. In order to debug your parameterized unit tests, do the following:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;Go to Tools &amp;raquo; Options &amp;raquo; Pex &amp;raquo; Diagnostic.&lt;/li&gt;&#xA;&lt;li&gt;Change the &lt;em&gt;BreakOnStart&lt;/em&gt; option to &lt;em&gt;True.&lt;/em&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgfjj0As1W5DnJHPq6nqYDIxi-HX_TXxruEvloqBQLG8h0pTbYUAZ8DTJGuTUxSCtipVixFtlubjEQSegFaMniwQjdXXKMgP1TpxHgt3xXeNXD-qzO3-Mfag-Ou5ek0SQB_aKf44vGm-A/s1600-h/Options_2013-08-13_13-01-05%25255B4%25255D.png&#34;&gt;&lt;img alt=&#34;Options_2013-08-13_13-01-05&#34; src=&#34;https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEixeR3zghTBtxNaC__zrvvK5IF4NCjt9Qbtk06Pz38iMZzXNlkQITRkFCWr9_fgzTnxx97po3idxTHKReET7dw5OFYkbt2-5rE3M3g04vypjCvAPBxp8Me7VrgNTBiSq6KphZfbScAxLg/?imgmax=800&#34; title=&#34;Options_2013-08-13_13-01-05&#34;&gt;&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Convert Microsoft Pex path conditions from Z3 native format to SMT-LIB</title>
      <link>http://localhost:1313/2013/08/convert-microsoft-pex-path-conditions.html</link>
      <pubDate>Thu, 01 Aug 2013 16:24:00 -0500</pubDate>
      <guid>http://localhost:1313/2013/08/convert-microsoft-pex-path-conditions.html</guid>
      <description>&lt;p&gt;We talked before about &lt;a href=&#34;http://ebeid-soliman.blogspot.com/2013/07/get-path-conditions-from-microsoft-pex.html&#34; title=&#34;Get path conditions from Microsoft Pex&#34;&gt;getting the code path conditions from Microsoft Pex&lt;/a&gt; as in &lt;a href=&#34;http://research.microsoft.com/en-us/um/redmond/projects/z3/old/index.html&#34; title=&#34;Z3 : An Efficient Theorem Prover&#34;&gt;Z3&lt;/a&gt; native format(.z3 file).&lt;/p&gt;&#xA;&lt;p&gt;Sometimes you may need to convert from Z3 native format to &lt;a href=&#34;http://www.smt-lib.org/&#34; title=&#34;SMT-LIB The Satisfiability Modulo Theories Library&#34;&gt;SMT-LIB&lt;/a&gt; standard. You can do that using the &lt;a href=&#34;http://ebeid-soliman.blogspot.com/2013/07/the-z3-constraint-solver-developer.html&#34; title=&#34;The Z3 Constraint Solver, a developer perspective&#34;&gt;Z3 C# APIs&lt;/a&gt;. The only trick here is: you have to use the Microsoft.Z3.dll that come with your current Microsoft Pex installation (C:\Program Files\Microsoft Pex\bin\Microsoft.Z3.dll).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Get path conditions from Microsoft Pex</title>
      <link>http://localhost:1313/2013/07/get-path-conditions-from-microsoft-pex.html</link>
      <pubDate>Wed, 24 Jul 2013 17:26:00 -0500</pubDate>
      <guid>http://localhost:1313/2013/07/get-path-conditions-from-microsoft-pex.html</guid>
      <description>&lt;p&gt;We talked in a previous &lt;a href=&#34;http://ebeid-soliman.blogspot.com/2013/04/why-pex-choose-these-inputs.html&#34; title=&#34;Why Pex Choose These Inputs&#34;&gt;post&lt;/a&gt; about Microsoft Pex and how it choose values to explore your code through symbolically executing it and getting all its paths. A code path is the represented by all the conditions that have to be satisfied in order to make the code execution go to this path. Your code conditional statements will lead to different paths according to different input values. Test cases generated by Pex represents the code behavior for specific input values that lead to specific code path.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Testing stateful components using Microsoft Pex</title>
      <link>http://localhost:1313/blog/testing-stateful-components-using-microsoft-pex/</link>
      <pubDate>Tue, 23 Jul 2013 17:34:00 -0500</pubDate>
      <guid>http://localhost:1313/blog/testing-stateful-components-using-microsoft-pex/</guid>
      <description>&lt;p&gt;&amp;lt;&amp;gt;&lt;br&gt;&#xA;Pattern. This pattern applies for statefull component x that expose members that may transition the state. For each member f(x), one defines a transition type Tf (x; o) which contains a method to invoke f(x) and where o is the test oracle.&lt;br&gt;&#xA;Let us illustrate this pattern with the XmlWriter class from the System.Xml library. This class contains a number of methods (Write&amp;hellip;) which have to be called in a particular order to build valid XML documents. The writer also exposes a WriteState property which gives a partial view on the state of the writer:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Parameterized Models Patterns using Microsoft Pex</title>
      <link>http://localhost:1313/blog/parameterized-models-patterns-using-microsoft-pex/</link>
      <pubDate>Thu, 02 May 2013 16:45:00 -0500</pubDate>
      <guid>http://localhost:1313/blog/parameterized-models-patterns-using-microsoft-pex/</guid>
      <description>&lt;p&gt;Pex provides an infrastructure to implement parameterized models. We refer to parameterized models as they build on top of Pex infrastructure to generate new parameters on the fly, which we usually refer as &lt;strong&gt;choices&lt;/strong&gt;. Parameterized models can be used to replace traditional mocked-based testing as a single model captures all possible behavior.&lt;br&gt;&#xA;For a modeled component, instead of defining a single input/output pair as with mock objects, a parameterized model can specify a general input/output relationship, and it can use test parameters to act in various ways. In unit testing, mock objects are used to simulate the behavior of external components in order to test each component in isolation.&lt;br&gt;&#xA;Although mock object frameworks have greatly improve the usability in recent years, mock-based testing is still a tedious task. Note that the term mock object is used for somewhat different concepts by developers practicing unit testing. The meaning ranges from very simple (empty) stubs to complex and precise behavior with expected inputs and correctly computed outputs.&lt;br&gt;&#xA;Martin Fowler discusses this in detail &lt;a href=&#34;http://www.martinfowler.com/articles/mocksArentStubs.html&#34;&gt;here&lt;/a&gt;. In this sense, the first parameterized model patterns we present start out as simple stubs, but the patterns allow sophisticated models that assert expected inputs and restrict possible outputs.&lt;br&gt;&#xA;There are many frameworks that make it easy to write mock objects—for example, for .NET. Similar to how NUnit relates to Pex, these existing frameworks make it easy to manage mock objects—for example, by reducing the amount of code that must be written—but they do not help in exploring different behaviors. Note that Pex comes with a simple stubs framework. This framework was designed to be friendly with the kind of code analysis Pex does.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Parameterized Test Patterns using Microsoft Pex</title>
      <link>http://localhost:1313/2013/05/parameterized-test-patterns-using.html</link>
      <pubDate>Thu, 02 May 2013 16:08:00 -0500</pubDate>
      <guid>http://localhost:1313/2013/05/parameterized-test-patterns-using.html</guid>
      <description>&lt;p&gt;We talked before about the difference between unit tests and parameterized unit tests. In this post we will talk about common patterns for writing good parameterized unit tests. Keep in mind that we will use these tests with Microsoft Pex (as an automatic test input generation tool) to get test inputs that trigger all the possible scenarios of the code-under-test.&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;Before anything, let’s clarify what are the questions we want to answer using the parameterized unit tests. There are  two core questions:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Microsoft Pex: Understanding Assumptions, Assertions, and Test-Case Failures</title>
      <link>http://localhost:1313/2013/04/microsoft-pex-understanding-assumptions.html</link>
      <pubDate>Mon, 29 Apr 2013 15:00:00 -0500</pubDate>
      <guid>http://localhost:1313/2013/04/microsoft-pex-understanding-assumptions.html</guid>
      <description>&lt;p&gt;In a previous post we started using Microsoft Pex and showed how it helped exploring all possible code paths, and how that helped discovering a defect in our program logic. In that example, even our program logic is defective, all test cases succeeded. A test case fails if there is an un-caught exception or a failed assertion.&lt;/p&gt;&#xA;&lt;p&gt;To see an example of a failed test case and how Pex could help in fixing it, let’s add the following basic function to our code:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Getting started with Microsoft Code Digger</title>
      <link>http://localhost:1313/2013/04/getting-started-with-microsoft-code.html</link>
      <pubDate>Fri, 26 Apr 2013 03:00:00 -0500</pubDate>
      <guid>http://localhost:1313/2013/04/getting-started-with-microsoft-code.html</guid>
      <description>&lt;p&gt;Microsoft Code Digger is Visual Studio 2012 extension that have been released few days ago by RiSE team at Microsoft Research (the same team who developed Pex). You can download the it from the Visual Studio Gallery &lt;a href=&#34;http://visualstudiogallery.msdn.microsoft.com/fb5badda-4ea3-4314-a723-a1975cbdabb4&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;Microsoft Code Digger uses the same engine that Pex uses, and the same techniques under the hood (dynamic symbolic execution and constraint solvers). The only constrain that Code Digger have is that it only works on public .NET code in Portable Class Libraries.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Why Pex Choose These Inputs</title>
      <link>http://localhost:1313/2013/04/why-pex-choose-these-inputs.html</link>
      <pubDate>Thu, 25 Apr 2013 03:00:00 -0500</pubDate>
      <guid>http://localhost:1313/2013/04/why-pex-choose-these-inputs.html</guid>
      <description>&lt;p&gt;In the example we gave in the previous post, it may seem that Pex chose random numbers as inputs for the Triang() method but it is not. But also its not all possible values for the inputs.&lt;/p&gt;&#xA;&lt;p&gt;Actually, Pex generates test inputs by analyzing your program code, so it is called whitebox test generation (as opposed to blackbox test generation). For every statement in the code, Pex will eventually try to create a test input that will reach that statement. Pex will do a case analysis for every conditional branch in the code—for example, if statements, assertions, and all operations that can throw exceptions.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Getting started with Microsoft Pex</title>
      <link>http://localhost:1313/2013/04/getting-started-with-microsoft-pex.html</link>
      <pubDate>Wed, 24 Apr 2013 03:06:00 -0500</pubDate>
      <guid>http://localhost:1313/2013/04/getting-started-with-microsoft-pex.html</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://research.microsoft.com/en-us/projects/pex/&#34;&gt;Microsoft Pex&lt;/a&gt; is a &lt;a href=&#34;http://research.microsoft.com/pubs/81193/fulltext.pdf&#34;&gt;white box test generation for .NET&lt;/a&gt; that came out of Microsoft Research and have been successfully integrated into Visual Studio 2010. It have been a result of collaborative work between Microsoft Research and the &lt;a href=&#34;https://sites.google.com/site/asergrp/&#34;&gt;Automated Software Engineering Research Group&lt;/a&gt; at &lt;a href=&#34;http://www.ncsu.edu/&#34;&gt;North Carolina State University&lt;/a&gt; led by  &lt;a href=&#34;http://www.csc.ncsu.edu/faculty/xie/&#34;&gt;Dr. Tao Xie&lt;/a&gt;.&lt;/p&gt;&#xA;&lt;p&gt;You can download and install Microsoft Pex for Visual Studio 2010 from &lt;a href=&#34;http://research.microsoft.com/en-us/projects/pex/downloads.aspx&#34;&gt;here&lt;/a&gt;. We have talked in a previous &lt;a href=&#34;http://ebeid-soliman.blogspot.com/2013/04/unit-tests-vs-parameterized-unit-tests.html&#34;&gt;post&lt;/a&gt; about parameterized unit tests and the possibilities it brings. In this post and the following we will explore Microsoft Pex and how it can help you in understanding the input/output behavior of your code, finding inputs that cause the code-under-test to crash, and exploring parameterized unit tests to check whether your code implements the desired functionality for all inputs.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Unit Tests vs Parametrized Unit Tests</title>
      <link>http://localhost:1313/2013/04/unit-tests-vs-parameterized-unit-tests.html</link>
      <pubDate>Mon, 22 Apr 2013 17:17:00 -0500</pubDate>
      <guid>http://localhost:1313/2013/04/unit-tests-vs-parameterized-unit-tests.html</guid>
      <description>&lt;h3 id=&#34;unit-tests&#34;&gt;Unit Tests&lt;/h3&gt;&#xA;&lt;p&gt;Using the conventions of NUnit unit tests as test methods contained in test classes. A parameterless method decorated with a custom attribute like [TestMethod] is a test method. Usually, each unit test explores a particular aspect of the behavior of the class-under-test.&lt;/p&gt;&#xA;&lt;p&gt;Here is a unit test written in C# that adds an element to a .NET ArrayList instance. The test first creates a new array list, where the parameter to the constructor is the initial capacity, then adds a new object to the array list, and finally checks that the addition was correctly performed by verifying that a subsequent index lookup operation returns the new object.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
