<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Microsoft Pex on Ebeid ElSayed</title>
    <link>https://ebeid.github.io/tags/microsoft-pex/</link>
    <description>Recent content in Microsoft Pex on Ebeid ElSayed</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <lastBuildDate>Tue, 13 Aug 2013 13:43:00 -0500</lastBuildDate>
    
	<atom:link href="https://ebeid.github.io/tags/microsoft-pex/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>How to debug your Pex parameterized unit tests</title>
      <link>https://ebeid.github.io/blog/2013-08-13-how-to-debug-your-pex-parameterized.html/</link>
      <pubDate>Tue, 13 Aug 2013 13:43:00 -0500</pubDate>
      
      <guid>https://ebeid.github.io/blog/2013-08-13-how-to-debug-your-pex-parameterized.html/</guid>
      <description>We talked before about Microsoft Pex, and how it choose the shown inputs. We then talked more about building blocks of parameterized unit tests and its patterns.
What we missed till now is how to debug your parameterized unit tests. In order to debug your parameterized unit tests, do the following:
 Go to Tools &amp;gt;&amp;gt; Options &amp;gt;&amp;gt; Pex &amp;gt;&amp;gt; Diagnostic. Change the BreakOnStart option to True.   Now set a break point at any line of code inside your parameterized unit test.</description>
    </item>
    
    <item>
      <title>Convert Microsoft Pex path conditions from Z3 native format to SMT-LIB</title>
      <link>https://ebeid.github.io/blog/2013-08-01-convert-microsoft-pex-path-conditions.html/</link>
      <pubDate>Thu, 01 Aug 2013 16:24:00 -0500</pubDate>
      
      <guid>https://ebeid.github.io/blog/2013-08-01-convert-microsoft-pex-path-conditions.html/</guid>
      <description>We talked before about getting the code path conditions from Microsoft Pex as in Z3 native format(.z3 file).
Sometimes you may need to convert from Z3 native format to SMT-LIB standard. You can do that using the Z3 C# APIs. The only trick here is: you have to use the Microsoft.Z3.dll that come with your current Microsoft Pex installation (C:\Program Files\Microsoft Pex\bin\Microsoft.Z3.dll).
To show how it works, let’s create a new C# console application.</description>
    </item>
    
    <item>
      <title>Get path conditions from Microsoft Pex</title>
      <link>https://ebeid.github.io/blog/2013-07-24-get-path-conditions-from-microsoft-pex.html/</link>
      <pubDate>Wed, 24 Jul 2013 17:26:00 -0500</pubDate>
      
      <guid>https://ebeid.github.io/blog/2013-07-24-get-path-conditions-from-microsoft-pex.html/</guid>
      <description>We talked in a previous post about Microsoft Pex and how it choose values to explore your code through symbolically executing it and getting all its paths. A code path is the represented by all the conditions that have to be satisfied in order to make the code execution go to this path. Your code conditional statements will lead to different paths according to different input values. Test cases generated by Pex represents the code behavior for specific input values that lead to specific code path.</description>
    </item>
    
    <item>
      <title>Parameterized Test Patterns using Microsoft Pex</title>
      <link>https://ebeid.github.io/blog/2013-05-02-parameterized-test-patterns-using.html/</link>
      <pubDate>Thu, 02 May 2013 16:08:00 -0500</pubDate>
      
      <guid>https://ebeid.github.io/blog/2013-05-02-parameterized-test-patterns-using.html/</guid>
      <description>We talked before about the difference between unit tests and parameterized unit tests. In this post we will talk about common patterns for writing good parameterized unit tests. Keep in mind that we will use these tests with Microsoft Pex (as an automatic test input generation tool) to get test inputs that trigger all the possible scenarios of the code-under-test.
 Before anything, let’s clarify what are the questions we want to answer using the parameterized unit tests.</description>
    </item>
    
    <item>
      <title>Microsoft Pex: Understanding Assumptions, Assertions, and Test-Case Failures</title>
      <link>https://ebeid.github.io/blog/2013-04-29-microsoft-pex-understanding-assumptions.html/</link>
      <pubDate>Mon, 29 Apr 2013 15:00:00 -0500</pubDate>
      
      <guid>https://ebeid.github.io/blog/2013-04-29-microsoft-pex-understanding-assumptions.html/</guid>
      <description>In a previous post we started using Microsoft Pex and showed how it helped exploring all possible code paths, and how that helped discovering a defect in our program logic. In that example, even our program logic is defective, all test cases succeeded. A test case fails if there is an un-caught exception or a failed assertion.
To see an example of a failed test case and how Pex could help in fixing it, let’s add the following basic function to our code:</description>
    </item>
    
    <item>
      <title>Getting started with Microsoft Code Digger</title>
      <link>https://ebeid.github.io/blog/2013-04-26-getting-started-with-microsoft-code.html/</link>
      <pubDate>Fri, 26 Apr 2013 03:00:00 -0500</pubDate>
      
      <guid>https://ebeid.github.io/blog/2013-04-26-getting-started-with-microsoft-code.html/</guid>
      <description>Microsoft Code Digger is Visual Studio 2012 extension that have been released few days ago by RiSE team at Microsoft Research (the same team who developed Pex). You can download the it from the Visual Studio Gallery here.
Microsoft Code Digger uses the same engine that Pex uses, and the same techniques under the hood (dynamic symbolic execution and constraint solvers). The only constrain that Code Digger have is that it only works on public .</description>
    </item>
    
    <item>
      <title>Why Pex Choose These Inputs</title>
      <link>https://ebeid.github.io/blog/2013-04-25-why-pex-choose-these-inputs.html/</link>
      <pubDate>Thu, 25 Apr 2013 03:00:00 -0500</pubDate>
      
      <guid>https://ebeid.github.io/blog/2013-04-25-why-pex-choose-these-inputs.html/</guid>
      <description>In the example we gave in the previous post, it may seem that Pex chose random numbers as inputs for the Triang() method but it is not. But also its not all possible values for the inputs.
Actually, Pex generates test inputs by analyzing your program code, so it is called whitebox test generation (as opposed to blackbox test generation). For every statement in the code, Pex will eventually try to create a test input that will reach that statement.</description>
    </item>
    
    <item>
      <title>Getting started with Microsoft Pex</title>
      <link>https://ebeid.github.io/blog/2013-04-24-getting-started-with-microsoft-pex.html/</link>
      <pubDate>Wed, 24 Apr 2013 03:06:00 -0500</pubDate>
      
      <guid>https://ebeid.github.io/blog/2013-04-24-getting-started-with-microsoft-pex.html/</guid>
      <description>Microsoft Pex is a white box test generation for .NET that came out of Microsoft Research and have been successfully integrated into Visual Studio 2010. It have been a result of collaborative work between Microsoft Research and the Automated Software Engineering Research Group at North Carolina State University led by Dr. Tao Xie.
You can download and install Microsoft Pex for Visual Studio 2010 from here. We have talked in a previous post about parameterized unit tests and the possibilities it brings.</description>
    </item>
    
    <item>
      <title>Unit Tests vs Parametrized Unit Tests</title>
      <link>https://ebeid.github.io/blog/2013-04-22-unit-tests-vs-parameterized-unit-tests.html/</link>
      <pubDate>Mon, 22 Apr 2013 17:17:00 -0500</pubDate>
      
      <guid>https://ebeid.github.io/blog/2013-04-22-unit-tests-vs-parameterized-unit-tests.html/</guid>
      <description>Unit Tests Using the conventions of NUnit unit tests as test methods contained in test classes. A parameterless method decorated with a custom attribute like [TestMethod] is a test method. Usually, each unit test explores a particular aspect of the behavior of the class-under-test.
Here is a unit test written in C# that adds an element to a .NET ArrayList instance. The test first creates a new array list, where the parameter to the constructor is the initial capacity, then adds a new object to the array list, and finally checks that the addition was correctly performed by verifying that a subsequent index lookup operation returns the new object.</description>
    </item>
    
  </channel>
</rss>