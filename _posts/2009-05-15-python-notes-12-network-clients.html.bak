---
title: 'Python Notes 12 : Network clients'
date: '2009-05-15T18:17:00.001-05:00'
author: Ebeid Soliman ElSayed
tags:
modified_time: '2009-05-15T18:17:49.335-05:00'
blogger_id: tag:blogger.com,1999:blog-59384554657271185.post-1836562697685840799
blogger_orig_url: http://ebeid-soliman.blogspot.com/2009/05/python-notes-12-network-clients.html
---

<p>After we have explored the basics of network programming in brief in the <a href="http://ebeid-soliman.blogspot.com/2009/05/python-notes-11-introduction-to-network.html">previous post</a>, we will discuss network clients in more details in this post.</p>  <p><strong>Understanding Sockets</strong>     <br />Sockets are an extension to the operating system's I/O system that enable communication between processes and machines. It can be treated the same as standard files, with the same interface methods so in many cases, a program need not know whether it's writing data to a file, the terminal, or a TCP connection. While many files are opened with the open () call, sockets are created with the socket () call and additional calls are needed to connect and activate them. </p>  <p><strong>Creating Sockets</strong></p>  <p>For a client program, creating a socket is generally a two-step process. </p>  <ol>   <li>Create the actual socket object. </li>    <li>Connect the socket to the remote server. </li> </ol>  <p>When you create a socket object, you need to tell the system two things: </p>  <ul>   <li>The communication type: the underlying protocol used to transmit data. Examples of protocols include IPv4 (current Internet standard), IPv6 (future Internet standard), IPX/ SPX (NetWare), and AFP (Apple file sharing). By far the most common is IPv4. </li>    <li>The protocol family: defines how data is transmitted.      <br />For Internet communications, which make up the bulk of this book, the communication type is almost always AF_INET (corresponding to IPv4). The protocol family is typically either:       <ul>       <li>SOCK_STREAM for TCP communications or </li>        <li>SOCK_DGRAM for UDP communications </li>     </ul>   </li> </ul>  <p>For a TCP connection, creating a socket generally uses    <br />code like this: </p>  <p><font color="#0000ff">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) </font>To connect the socket, you'll generally need to provide a tuple containing the remote hostname or IP address and the remote port. Connecting a socket typically looks like this:     <br /><font color="#0000ff">s.connect((&quot;www.example.com&quot;, 80))</font> </p>  <p><strong>Finding the port number</strong></p>  <p>Most operating systems ship with a list of well-known server port numbers which you can query. On windows systems, you can find this file at C:\Windows\System32\drivers\etc\services. To query this list, you need two parameters: </p>  <ul>   <li>A protocol name </li>    <li>A port name. </li> </ul>  <p>This query is like:</p>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt;print socket.getservbyname(‘ftp’,’tcp’)</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">21</font></p> </blockquote>  <p>You didn't have to know in advance that FTP uses port 80. </p>  <p><strong>Getting Information from a Socket</strong>     <br />Once you've established a socket connection, you can find out some useful information from it.</p>  <p>s.getsockname() #Get your IP address and port number</p>  <p>s.getpeername() #Get the remote machine IP address and port number</p>  <p><strong>Socket Exceptions</strong></p>  <p>Different network calls can raise different exceptions when network errors occur. Python's socket module actually defines four possible exceptions: </p>  <ul>   <li>socket.error for general I/O and communication problems. </li>    <li>socket.gaierror for errors looking up address information </li>    <li>socket.herror for other addressing errors. </li>    <li>socket.timeout for handling timeouts that occur after settimeout() has been called on a socket. </li> </ul>  <p><strong>Complete Example</strong></p>  <p>The example program takes three command-line arguments: a host to which it will connect, a port number or name on the server, and a file to request from the server. The program will connect to the server, send a simple HTTP    <br />request for the given filename, and display the result. Along the way, it exercises care to handle various types of potential errors. </p>  <blockquote>   <p><font color="#0000ff">import socket, sys        <br />host = sys.argv[l]         <br />textport = sys.argv[2]         <br />filename = sys.argv[3]         <br />try:         <br />&#160;&#160;&#160; s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)         <br />except socket.error, e:&#160; <br />&#160;&#160;&#160; print &quot;Strange error creating socket: %s&quot; % e&#160; <br />&#160;&#160;&#160; sys.exit(l)         <br />&#160;&#160;&#160; # Try parsing it as a numeric port number.         <br />try:         <br />&#160;&#160;&#160; port = int(textport)         <br />except ValueError:         <br />&#160;&#160;&#160; # That didn't work, so it's probably a protocol name.         <br />&#160;&#160;&#160; # Look it up instead,         <br />try:         <br />&#160;&#160;&#160; port = socket.getservbyname(textport, 'tcp')         <br />&#160;&#160;&#160; except socket.error, e:         <br />&#160;&#160;&#160; print &quot;Couldn't find your port: %s&quot; % e         <br />&#160;&#160;&#160; sys.exit(i) </font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">try:        <br />&#160;&#160;&#160; s.connect((host, port))         <br />except socket.gaierror, e:         <br />&#160;&#160;&#160; print &quot;Address-related error connecting to server: %s&quot; % e         <br />&#160;&#160;&#160; sys.exit(i)         <br />except socket.error, e:         <br />&#160;&#160;&#160; print &quot;Connection error: %s&quot; % e         <br />&#160;&#160;&#160; sys.exit(l)         <br />try:         <br />&#160;&#160;&#160; s.sendall(&quot;CET %s HTTP/1.0\r\n\r\n&quot; % filename)         <br />except socket.error, e:         <br />&#160;&#160;&#160; print &quot;Error sending data: %s&quot; % e         <br />&#160;&#160;&#160; sys.exit(i)         <br />while 1:         <br />&#160;&#160;&#160; try:         <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; buf = s.recvB048)         <br />&#160;&#160;&#160; except socket.error, e:         <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; print &quot;Error receiving data: %s&quot; % e         <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; sys.exit(l)         <br />&#160;&#160;&#160; if not len(buf):         <br />&#160;&#160;&#160;&#160;&#160;&#160;&#160; break         <br />&#160;&#160;&#160; sys.stdout.write(buf)</font> </p> </blockquote>  <p><strong>Using User Datagram Protocol</strong></p>  <p>In UDP there is no sufficient control over how data is sent and received. Working with UDP clients differs than TCP clients in the following:</p>  <ul>   <li>When create the socket ask for SOCKDGRAM      <br />instead of SOCKSTREAM; this indicates to the operating system that the socket will       <br />be used for UDP instead of TCP communications. </li>    <li>When call socket.getservbyname(), pass ‘udp’ instead of ‘tcp’. </li> </ul>  <p>In this post we discussed network clients in a little bit depth. In the next post we will discuss network servers.</p>
