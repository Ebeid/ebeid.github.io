---
title: Getting Started with MongoDB – Part 2
date: '2013-07-12T17:15:00.001-05:00'

tags:
- MongoDB
- JSON
- NoSQL
modified_time: '2013-07-16T16:34:00.464-05:00'
blogger_id: tag:blogger.com,1999:blog-59384554657271185.post-8218800317562840497
blogger_orig_url: http://ebeid-soliman.blogspot.com/2013/07/getting-started-with-mongodb-part-2.html
---

<p>In the previous post we explored the basics of MongoDB. In this post we going to dig deeper in MongoDB.</p> <h3>Indexing</h3> <p>Whenever a new collection is created, MongoDB automatically creates an index by the <em>_id </em>field. These indexes can be found in the system.indexes collection. You can show all indexes in the database using <font color="#0000ff">db.system.indexes.find()</font> . Most queries will include more fields than just the _id, so we need to make indexes on those fields.</p> <p>Before creating more indexes, let’s see what is the performance of a sample query without creating any indexes other than the automatically created one for _id. Create the following function to generate random phone numbers.</p> <blockquote> <p><font color="#0000ff">function (area,start,stop) {<br>for(var i=start; i &lt; stop; i++) {<br>var country = 1 + ((Math.random() * 8) &lt;&lt; 0);<br>var num = (country * 1e10) + (area * 1e7) + i;<br>db.phones.insert({<br>_id: num,<br>components: {<br>country: country,<br>area: area,<br>prefix: (i * 1e-4) &lt;&lt; 0,<br>number: i<br>},<br>display: "+" + country + " " + area + "-" + i<br>});</font></p></blockquote> <p>Run the function with a three-digit area code (like 800) and a range of seven digit numbers (5,550,000 to 5,650,000)</p> <blockquote> <p><font color="#0000ff">populatePhones( 800, 5550000, 5650000 )</font></p></blockquote> <p>Now we expecting to see a new index created for our new collection.</p> <blockquote> <p><font color="#0000ff">&gt; db.system.indexes.find()<br>{ "v" : 1, "key" : { "_id" : 1 }, "ns" : "newdb.towns", "name" : "_id_" }<br>{ "v" : 1, "key" : { "_id" : 1 }, "ns" : "newdb.countries", "name" : "_id_" }<br>{ "v" : 1, "key" : { "_id" : 1 }, "ns" : "newdb.phones", "name" : "_id_" }</font></p></blockquote> <p>Now let’s check the query without an index. The explain() method is used to output details of a given operation and can help us here.</p> <blockquote> <p><font color="#0000ff">&gt; db.phones.find( { display : "+1 800-5650001" } ).explain()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "cursor" : "<strong><u>BasicCursor</u></strong>",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "isMultiKey" : false,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "n" : 0,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "nscannedObjects" : 100000,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "nscanned" : 100000,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "nscannedObjectsAllPlans" : 100000,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "nscannedAllPlans" : 100000,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "scanAndOrder" : false,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "indexOnly" : false,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "nYields" : 0,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "nChunkSkips" : 0,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "millis" : <strong><u>134</u></strong>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "indexBounds" : {</font></p></blockquote> <blockquote> <p><font color="#0000ff">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "server" : "ESOLIMAN:27017"<br>}</font></p></blockquote> <p>Just to make things simple, we will look at the millis field only which gives the milliseconds needed to complete the query. Now it is 134.</p> <p>Now we going to create an index and see how it improves our query execution time. We create an index by calling <strong>ensureIndex(fields,options)</strong> on the collection. The fields parameter is an object containing the fields to be indexed against. The options parameter describes the type of index to make. On production environments, creating an index on a large collection can be slow and resource-intensive, you should create them in off-peak times. In our case we going to build a unique index on the display field and we will drop duplicate entries.</p> <blockquote> <p><font color="#0000ff">&gt; db.phones.ensureIndex(<br>... { display : 1 },<br>... { unique : true, dropDups : true }<br>... )</font></p></blockquote> <p>lets try explain() 
of find() and see the new value for millis field. Query execution time improved, from 134 down to 16.</p> <blockquote> <p><font color="#0000ff">&gt; db.phones.find( { display : "+1 800-5650001" } ).explain()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "cursor" : "<strong><u>BtreeCursor display_1</u></strong>",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "isMultiKey" : false,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "n" : 0,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "nscannedObjects" : 0,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "nscanned" : 0,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "nscannedObjectsAllPlans" : 0,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "nscannedAllPlans" : 0,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "scanAndOrder" : false,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "indexOnly" : false,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "nYields" : 0,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "nChunkSkips" : 0,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "millis" : <strong><u>16</u></strong>,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "indexBounds" : {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "display" : [<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "+1 800-5650001",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "+1 800-5650001"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ]<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "server" : "ESOLIMAN:27017"<br>}</font></p></blockquote> <p>Notice the cursor changed from a Basic to a B-tree cursor. MongoDB is no longer doing<br>a full collection scan but instead walking the tree to retrieve the value.</p> <p>Mongo can build your index on nested values: <font color="#0000ff">db.phones.ensureIndex({ "components.area": 1 }, { background : 1 })</font></p> <h3>Aggregations</h3> <p><strong>count()</strong> counts the number of matching documents. It takes a query and returns a number.</p> <blockquote> <p><font color="#0000ff">&gt; db.phones.count({'components.number': { $gt : 5599999 } })<br>100000</font></p></blockquote> <p><font color="#000000"><strong>distinct()</strong> returns each matching value where one or more exists.</font></p> <blockquote> <p><font color="#0000ff">&gt; db.phones.distinct('components.number', {'components.number': { $lt : 5550005 } })<br>[ 5550000, 5550001, 5550002, 5550003, 5550004 ]</font></p></blockquote> <p><font color="#000000"><strong>group()</strong> groups documents in a collection by the specified keys and performs simple aggregation functions such as computing counts and sums. It is similar to GROUP BY in SQL. It accepts the following parameters</font></p> <ul> <li><em>key</em> – Specifies one or more document fields to group by.</li> <li><em>reduce</em> – Specifies a function for the group operation perform on the documents during the grouping operation, such as compute a sum or a count. The aggregation function takes two arguments: the current document and the aggregate result for the previous documents in the group.</li> <li><em>initial</em> – Initializes the aggregation result document.</li> <li><em>keyf</em> – Optional. Alternative to the key field. Specifies a function that creates a “key object” for use as the grouping key. Use the keyf instead of key to group by calculated fields rather than existing document fields. Like HAVING in SQL.</li> <li><em>cond<
/em> – Optional. Specifies the selection criteria to determine which documents in the collection to process. If you omit the cond field, db.collection.group() processes all the documents in the collection for the group operation.</li> <li><em>finalize</em> – Optional. Specifies a function that runs each item in the result set before db.collection.group() returns the final value. This function can either modify the result document or replace the result document as a whole.</li></ul> <blockquote> <p><font color="#0000ff">&gt; db.phones.group({<br>... initial : { count : 0 },<br>... reduce : function(phone, output) { output.count++; },<br>... cond : { 'components.number' : { $gt : 5599999 } },<br>... key : { 'components.area' : true }<br>... })<br>[<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "components.area" : 800,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "count" : 50000<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "components.area" : 855,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "count" : 50000<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>]</font></p></blockquote> <p>The first thing we did here was set an initial object with a field named count set to 0—fields created here will appear in the output. Next we describe what to do with this field by declaring a reduce function that adds one for every document we encounter. Finally, we gave group a condition restricting which documents to reduce over.</p> <h3>Server-Side Commands</h3> <p>All queries and operations we did till now, execute on the client side. The db object provides a command named eval(), which passes the given function to the server. This dramatically reduces the communication between client and server. It is similar to stored procedures in SQL.</p> <p>There is a also a set of prebuilt commands that can be executed on the server. Use <font color="#0000ff">db.listCommands()</font> to get a list of these <a title="db.listCommands()" href="http://docs.mongodb.org/manual/reference/method/db.listCommands/#db.listCommands" target="_blank">commands</a>. To run any command on the server use <font color="#0000ff">db.runCommand()</font> like <font color="#0000ff">db.runCommand({ "count" : "phones" })</font></p> <p><font color="#000000">Although it is not recommended, you can <a title="Store a JavaScript function on the Server" href="http://docs.mongodb.org/manual/tutorial/store-javascript-function-on-server/" target="_blank">store a JavaScript function on the server</a> for later reuse.</font></p> <h3>MapReduce</h3> <p><font color="#000000"><a title="MapReduce: Simplified Data Processing on Large Clusters" href="http://research.google.com/archive/mapreduce.html" target="_blank">MapReduce</a> is a framework for parallelizing problems. Generally speaking the parallelization happens on two steps:</font></p> <ul> <li><b>"Map" step:</b> The master node takes the input, divides it into smaller sub-problems, and distributes them to worker nodes. A worker node may do this again in turn, leading to a multi-level <a href="http://en.wikipedia.org/wiki/Tree_(data_structure)">tree</a> structure. The worker node processes the smaller problem, and passes the answer back to its master node.</li> <li><b>"Reduce" step:</b> The master node then collects the answers to all the sub-problems and combines them in some way to form the output – the answer to the problem it was originally trying to solve.</li></ul> <p>To show the MapReduce framework in action, let’s build on the phones collections that we created previously. Let’s generate a report that counts all phone numbers that contain the same digits for each country.</p> <p>First we create a <em>helper</em> function that extracts an array of all distinct numbers (this step is
 not a MapReduce step).</p> <blockquote> <p><font color="#0000ff">&gt; distinctDigits = function(phone) {<br>... var<br>... number = phone.components.number + '',<br>... seen = [],<br>... result = [],<br>... i = number.length;<br>... while(i--) {<br>...&nbsp; seen[+number[i]] = 1;<br>...&nbsp; }<br>... for (i=0; i&lt;10; i++) {<br>...&nbsp; if (seen[i]) {<br>...&nbsp;&nbsp; result[result.length] = i;<br>...&nbsp;&nbsp; }<br>...&nbsp; }<br>... return result;<br>... }</font></p></blockquote> <blockquote> <p><font color="#0000ff">&gt; db.eval("distinctDigits(db.phones.findOne({ 'components.number' : 5551213 }))")<br>[ 1, 2, 3, 5 ]</font></p></blockquote> <p>Now let’s find find distinct numbers of each country. Since we need to query by country later, we will add the distinct digits array and country as compound key. For each distinct digits array in each country, we will add a count field that hold the value 1. </p> <blockquote> <p><font color="#0000ff">&gt; map = function() {<br>... var digits = distinctDigits(this);<br>... emit( { digits : digits, country : this.components.country } , { count : 1 } );<br>... }</font></p></blockquote> <p>The reducer function will all these 1s that have been emitted from the map function.</p> <blockquote> <p><font color="#0000ff">&gt;reduce = function(key, values) {<br>... var total = 0;<br>... for(var i=0; i&lt;values.length; i++) {<br>...&nbsp; total += values[i].count;<br>...&nbsp; }<br>...&nbsp; return { count : total };<br>... }</font></p></blockquote> <p>Now it is time to put all pieces together and start the whole thing (the input collection, map function, reduce function, output collection).</p> <blockquote> <p><font color="#0000ff">&gt; results = db.runCommand({<br>... mapReduce : 'phones',<br>... map : map,<br>... reduce : reduce,<br>... out : 'phones.report'<br>... })<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "result" : "phones.report",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "timeMillis" : 21084,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "counts" : {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "input" : 200000,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "emit" : 200000,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "reduce" : 48469,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "output" : 3489<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; },<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "ok" : 1<br>}</font></p></blockquote> <p>Now you can query the output collection like any other collection</p> <blockquote> <p><font color="#0000ff">&gt; db.phones.report.find()<br>{ "_id" : { "digits" : [&nbsp; 0,&nbsp; 1,&nbsp; 2,&nbsp; 3,&nbsp; 4,&nbsp; 5,&nbsp; 6 ], "country" : 1 }, "value" : { "count" : 37 } }<br>{ "_id" : { "digits" : [&nbsp; 0,&nbsp; 1,&nbsp; 2,&nbsp; 3,&nbsp; 4,&nbsp; 5,&nbsp; 6 ], "country" : 2 }, "value" : { "count" : 23 } }<br>{ "_id" : { "digits" : [&nbsp; 0,&nbsp; 1,&nbsp; 2,&nbsp; 3,&nbsp; 4,&nbsp; 5,&nbsp; 6 ], "country" : 3 }, "value" : { "count" : 17 } }<br>{ "_id" : { "digits" : [&nbsp; 0,&nbsp; 1,&nbsp; 2,&nbsp; 3,&nbsp; 4,&nbsp; 5,&nbsp; 6 ], "country" : 4 }, "value" : { "count" : 29 } }<br>{ "_id" : { "digits" : [&nbsp; 0,&nbsp; 1,&nbsp; 2,&nbsp; 3,&nbsp; 4,&nbsp; 5,&nbsp; 6 ], "country" : 5 }, "value" : { "count" : 34 } }<br>{ "_id" : { "digits" : [&nbsp; 0,&nbsp; 1,&nbsp; 2,&nbsp; 3,&nbsp; 4,&nbsp; 5,&nbsp; 6 ], "country" : 6 }, "value" : { "count" : 35 } }<br>{ "_id" : { "digits" : [&nbsp; 0,&nbsp; 1,&nbsp; 2,&nbsp; 3,&nbsp; 4,&nbsp; 5,&nbsp; 6 ], "country" : 7 }, "value" : { "count" : 33 } }<br>{ "_id" : { "digits" : [&nbsp; 0,&nbsp; 1,&nbsp; 2,&nbsp; 3,&nbsp; 4,&nbsp; 5,&nbsp; 6 ], "country" : 8 }, "value" : { "count" : 32 } }<br>{ "_id" : { "digits" : [&nbsp; 0,&nbsp; 1,&nbsp; 2,&nbsp; 3,&nbsp; 5 ], "country" : 1 }, "value" : { "count" : 5 } }<br>{ "_id" : { "digits" : [&nbsp; 0,&nbsp; 1,&nbsp; 2,&nbsp; 3,&nbsp; 5 ], "country" : 2 }, "val
ue" : { "count" : 7 } }<br>{ "_id" : { "digits" : [&nbsp; 0,&nbsp; 1,&nbsp; 2,&nbsp; 3,&nbsp; 5 ], "country" : 3 }, "value" : { "count" : 3 } }<br>{ "_id" : { "digits" : [&nbsp; 0,&nbsp; 1,&nbsp; 2,&nbsp; 3,&nbsp; 5 ], "country" : 4 }, "value" : { "count" : 6 } }<br>{ "_id" : { "digits" : [&nbsp; 0,&nbsp; 1,&nbsp; 2,&nbsp; 3,&nbsp; 5 ], "country" : 5 }, "value" : { "count" : 5 } }<br>{ "_id" : { "digits" : [&nbsp; 0,&nbsp; 1,&nbsp; 2,&nbsp; 3,&nbsp; 5 ], "country" : 6 }, "value" : { "count" : 10 } }<br>{ "_id" : { "digits" : [&nbsp; 0,&nbsp; 1,&nbsp; 2,&nbsp; 3,&nbsp; 5 ], "country" : 7 }, "value" : { "count" : 5 } }<br>{ "_id" : { "digits" : [&nbsp; 0,&nbsp; 1,&nbsp; 2,&nbsp; 3,&nbsp; 5 ], "country" : 8 }, "value" : { "count" : 7 } }<br>{ "_id" : { "digits" : [&nbsp; 0,&nbsp; 1,&nbsp; 2,&nbsp; 3,&nbsp; 5,&nbsp; 6 ], "country" : 1 }, "value" : { "count" : 95 } }<br>{ "_id" : { "digits" : [&nbsp; 0,&nbsp; 1,&nbsp; 2,&nbsp; 3,&nbsp; 5,&nbsp; 6 ], "country" : 2 }, "value" : { "count" : 104 } }<br>{ "_id" : { "digits" : [&nbsp; 0,&nbsp; 1,&nbsp; 2,&nbsp; 3,&nbsp; 5,&nbsp; 6 ], "country" : 3 }, "value" : { "count" : 108 } }<br>{ "_id" : { "digits" : [&nbsp; 0,&nbsp; 1,&nbsp; 2,&nbsp; 3,&nbsp; 5,&nbsp; 6 ], "country" : 4 }, "value" : { "count" : 113 } }<br>Type "it" for more</font></p></blockquote> <p>or</p> <blockquote> <p><font color="#0000ff">&gt; db.phones.report.find({'_id.country' : 8})<br>{ "_id" : { "digits" : [&nbsp; 0,&nbsp; 1,&nbsp; 2,&nbsp; 3,&nbsp; 4,&nbsp; 5,&nbsp; 6 ], "country" : 8 }, "value" : { "count" : 32 } }<br>{ "_id" : { "digits" : [&nbsp; 0,&nbsp; 1,&nbsp; 2,&nbsp; 3,&nbsp; 5 ], "country" : 8 }, "value" : { "count" : 7 } }<br>{ "_id" : { "digits" : [&nbsp; 0,&nbsp; 1,&nbsp; 2,&nbsp; 3,&nbsp; 5,&nbsp; 6 ], "country" : 8 }, "value" : { "count" : 127 } }<br>{ "_id" : { "digits" : [&nbsp; 0,&nbsp; 1,&nbsp; 2,&nbsp; 3,&nbsp; 5,&nbsp; 6,&nbsp; 7 ], "country" : 8 }, "value" : { "count" : 28 } }<br>{ "_id" : { "digits" : [&nbsp; 0,&nbsp; 1,&nbsp; 2,&nbsp; 3,&nbsp; 5,&nbsp; 6,&nbsp; 8 ], "country" : 8 }, "value" : { "count" : 27 } }<br>{ "_id" : { "digits" : [&nbsp; 0,&nbsp; 1,&nbsp; 2,&nbsp; 3,&nbsp; 5,&nbsp; 6,&nbsp; 9 ], "country" : 8 }, "value" : { "count" : 29 } }<br>{ "_id" : { "digits" : [&nbsp; 0,&nbsp; 1,&nbsp; 2,&nbsp; 3,&nbsp; 5,&nbsp; 7 ], "country" : 8 }, "value" : { "count" : 10 } }<br>{ "_id" : { "digits" : [&nbsp; 0,&nbsp; 1,&nbsp; 2,&nbsp; 3,&nbsp; 5,&nbsp; 8 ], "country" : 8 }, "value" : { "count" : 7 } }<br>{ "_id" : { "digits" : [&nbsp; 0,&nbsp; 1,&nbsp; 2,&nbsp; 3,&nbsp; 5,&nbsp; 9 ], "country" : 8 }, "value" : { "count" : 8 } }<br>{ "_id" : { "digits" : [&nbsp; 0,&nbsp; 1,&nbsp; 2,&nbsp; 4,&nbsp; 5 ], "country" : 8 }, "value" : { "count" : 3 } }<br>{ "_id" : { "digits" : [&nbsp; 0,&nbsp; 1,&nbsp; 2,&nbsp; 4,&nbsp; 5,&nbsp; 6 ], "country" : 8 }, "value" : { "count" : 121 } }<br>{ "_id" : { "digits" : [&nbsp; 0,&nbsp; 1,&nbsp; 2,&nbsp; 4,&nbsp; 5,&nbsp; 6,&nbsp; 7 ], "country" : 8 }, "value" : { "count" : 25 } }<br>{ "_id" : { "digits" : [&nbsp; 0,&nbsp; 1,&nbsp; 2,&nbsp; 4,&nbsp; 5,&nbsp; 6,&nbsp; 8 ], "country" : 8 }, "value" : { "count" : 27 } }<br>{ "_id" : { "digits" : [&nbsp; 0,&nbsp; 1,&nbsp; 2,&nbsp; 4,&nbsp; 5,&nbsp; 6,&nbsp; 9 ], "country" : 8 }, "value" : { "count" : 17 } }<br>{ "_id" : { "digits" : [&nbsp; 0,&nbsp; 1,&nbsp; 2,&nbsp; 4,&nbsp; 5,&nbsp; 7 ], "country" : 8 }, "value" : { "count" : 4 } }<br>{ "_id" : { "digits" : [&nbsp; 0,&nbsp; 1,&nbsp; 2,&nbsp; 4,&nbsp; 5,&nbsp; 8 ], "country" : 8 }, "value" : { "count" : 4 } }<br>{ "_id" : { "digits" : [&nbsp; 0,&nbsp; 1,&nbsp; 2,&nbsp; 4,&nbsp; 5,&nbsp; 9 ], "country" : 8 }, "value" : { "count" : 7 } }<br>{ "_id" : { "digits" : [&nbsp; 0,&nbsp; 1,&nbsp; 2,&nbsp; 5 ], "country" : 8 }, "value" : { "count" : 14 } }<br>{ "_id" : { "digits" : [&nbsp; 0,&nbsp; 1,&nbsp; 2,&nbsp; 5,&nbsp; 6 ], "country" : 8 }, "value" : { "count" : 162 } }<br>{ "_id" : { "digits" : [&nbsp; 0,&nbsp; 1,&nbsp; 2,&nbsp; 5,&nbsp; 6,&nbsp; 7 ], "country" : 8 }, "value" : { "count" : 95 } }<br>Type "it" for more</font></p></blockquote> <p>The unique emitted key
s are under the field <em>_id</em>, and all of the data returned from the reducers are<br>under the field <em>value</em>. If you prefer that the mapreducer just output the results, rather than outputting to a collection, you can set the out value to { inline : 1 }, but bear in mind there is a limit to the size of a result you can output (16 MB).</p> <p>In some situations you may need to feed the reducer function’s output into another reducer function. In these situations we need to carefully handle both cases: either map’s output or another reduce’s output.</p> <p>MongoDB have so many features that we didn’t even mentioned here. In later posts will continue working on them.</p> <h3><font color="#0000ff"></font></h3>
