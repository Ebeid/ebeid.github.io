---
title: 'Python Notes – 8 : Object-Oriented Basics'
date: '2009-03-27T01:51:00.000-05:00'

tags:
- Python
modified_time: '2009-05-15T01:55:26.784-05:00'
blogger_id: tag:blogger.com,1999:blog-59384554657271185.post-4961343029819958668
blogger_orig_url: http://ebeid-soliman.blogspot.com/2009/03/python-notes-8.html
---

<p>Welcome to our eighth note in our Python learning process. This note will talk about object oriented features in Python.</p>  <h4>Classes and Objects</h4>  <p>A class definition looks like this:</p>  <blockquote>   <p><font color="#0000ff">class Point:</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; pass</font></p> </blockquote>  <p>Class definitions can appear anywhere in a program, but they are usually near the beginning (after the import statements). By creating the Point class, we created a new type, also called Point. The members of this type are called instances of the type or objects. Creating a new instance is called instantiation. To instantiate a Point object, we call a function named Point:</p>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; blank = Point()</font></p> </blockquote>  <p>The variable blank is assigned a reference to a new Point object. A function like Point that creates new objects is called a constructor. If you tried to get the type of blank, you got instance:</p>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; type(blank)</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&lt;type 'instance'&gt;</font></p> </blockquote>  <p>If you tried to print blank:</p>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; print blank</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&lt;__main__.point instance at 0x01922AF8&gt;</font></p> </blockquote>  <p>The result indicates that blank is an instance of the Point class and it was defined in __main__ . 0x01922AF8 is the unique identifier for this object, written in hexadecimal (base 16).</p>  <h4>Attributes</h4>  <p>We can add new data to an instance using dot notation:</p>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; blank.x = 3.0</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; blank.y = 4.0</font></p> </blockquote>  <p>These new data items called attributes.</p>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; print blank.y</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">4.0</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; x = blank.x</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; print x</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">3.0</font></p> </blockquote>  <h4>Sameness</h4>  <p>To find out if two references refer to the same object, use the == operator. For example:</p>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; p1 = Point()</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; p1.x = 3</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; p1.y = 4</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; p2 = Point()</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; p2.x = 3</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; p2.y = 4</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; p1 == p2</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">0</font></p> </blockquote>  <p>Even though p1 and p2 contain the same coordinates, they are not the same object. If we assign p1 to p2, then the two variables are aliases of the same object:</p>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; p2 = p1</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; p1 == p2</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">1</font></p> </blockquote>  <p>This type of equality is called <em>shallow equality</em> because it compares only the references, not the contents of the objects. To compare the contents of the objects - <em>deep equality</em> - we can write our own function to do that, like that:</p>  <blockquote>   <p><font color="#0000ff">def samePoint(p1, p2) :</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; return (p1.x == p2.x) and (p1.y == p2.y)</font></p> </blockquote>  <p
>Now if we create two different objects that contain the same data, we can use samePoint to find out if they represent the same point.</p>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; p1 = Point()</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; p1.x = 3</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; p1.y = 4</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; p2 = Point()</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; p2.x = 3</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; p2.y = 4</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; samePoint(p1, p2)</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">1</font></p> </blockquote>  <h4>Copying</h4>  <p>Aliasing can make a program difficult to read because changes made in one place might have unexpected effects in another place. Copying an object is often an alternative to aliasing. The copy module contains a function called copy that can duplicate any object:</p>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; import copy</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; p1 = Point()</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; p1.x = 3</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; p1.y = 4</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; p2 = copy.copy(p1)</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; p1 == p2</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">0</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; samePoint(p1, p2)</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">1</font></p> </blockquote>  <p>Copy works fine for objects that doesn't contain any embedded objects. If the object contains references to other objects, Copy will copy the embedded references to the destination. This ends up that the both copies reference the same internal objects. </p>  <p>You can use deepcopy which copies not only the object but also any embedded objects. </p>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; b2 = copy.deepcopy(b1)</font></p> </blockquote>  <p>Now b1 and b2 are completely separate objects.</p>  <h4>The initialization method</h4>  <p>The initialization method is a special method that is invoked when an object is created. The name of this method is __init__.</p>  <blockquote>   <p><font color="#0000ff">class point:</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; def __init__(self, x = 0, y = 0):</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160;&#160;&#160;&#160;&#160; Self.x = x</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160;&#160;&#160;&#160;&#160; Slef.y = y</font></p> </blockquote>  <p>When we invoke the point constructor, the arguments we provide are passed along to init:</p>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; first = point(5,7)</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; first.x</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">5</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; first.y</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">7</font></p> </blockquote>  <p>Because the parameters are optional, we can omit them:</p>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; second = point()</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; second.x</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">0</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; second.y</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">0</font></p> </blockquote>  <p>We can also provide a subset of the parameters by naming them explicitly:</p>  <blockquo
te>   <p><font color="#0000ff">&gt;&gt;&gt; third = point(y=10)</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; third.x</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">0</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; third.y</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">10</font></p> </blockquote>  <h4>The __str__ method</h4>  <p>The __str__ method of any class is called by the Python in any operation that requires the class instance to be converted to string. Operations like that are print. Syntax like that:</p>  <blockquote>   <p><font color="#0000ff">class xyz:</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; def __str__(self):</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160;&#160;&#160;&#160;&#160; return &quot;Our class xyz&quot;</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; a = xyz()</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; a</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&lt;__main__.xyz instance at 0x02627300&gt;</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; print y</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">Our class xyz</font></p> </blockquote>  <h4>Instances as parameters</h4>  <p>You can pass an instance as a parameter in the usual way. For example:</p>  <blockquote>   <p><font color="#0000ff">def printPoint(p):</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; print '(' + str(p.x) + ', ' + str(p.y) + ')'</font></p> </blockquote>  <h4>Instances as return values</h4>  <p>Functions can return instances. For example:</p>  <blockquote>   <p><font color="#0000ff">def sumPoints(A,B)</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; Z = Point ()</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; Z.x = A.x + B.x</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; Z.y = A.y + B.y</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; return Z</font></p> </blockquote>  <h4>Operator overloading</h4>  <p>Operator overloading means changing the definition and behavior of the built-in operators when they are applied to user-defined types. For example, to override the addition operator + , we provide a method named __add__ in our point class :</p>  <blockquote>   <p><font color="#0000ff">class Point:</font></p>    <p><font color="#0000ff">&#160;&#160;&#160; def __add__(self, other):</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160;&#160;&#160;&#160;&#160; return Point(self.x + other.x, self.y + other.y)</font></p> </blockquote>  <p>the first parameter is the object on which the method is invoked. The second parameter is conveniently named other to distinguish it from self. Now, when we apply the + operator to Point objects, Python invokes add :</p>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; p1 = Point(3, 4)</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; p2 = Point(5, 7)</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; p3 = p1 + p2</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; print p3</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">(8, 11)</font></p> </blockquote>  <p>The expression p1 + p2 is equivalent to p1. add (p2), but obviously more elegant. You can change the behavior of many operators through overloading their respective functions, which are available at <a href="http://www.python.org/doc/2.2/ref/numeric-types.html">http://www.python.org/doc/2.2/ref/numeric-types.html</a></p>  <h4>Inheritance</h4>  <p>Inheritance is the ability to define a new class that is a modified version of an existing class. The new class inherits all of the methods of the existing class. The new class may be
 called child class or subclass. The syntax is like:</p>  <blockquote>   <p><font color="#0000ff">class class1(object):</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; K = 7</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; def __init__(self, color='green'):</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160;&#160;&#160;&#160;&#160; Self.color = color</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; def Hello1(self):</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160;&#160;&#160;&#160;&#160; Print &quot;Hello from class1&quot;</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; def printColor(self):</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160;&#160;&#160;&#160;&#160; print &quot;preferred &quot;, self.color</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">class class2(class1):</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; def Hello2(self):</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; print &quot;Hello from class2&quot;</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; print self.k</font></p> </blockquote>  <p>Here class2 is the child of class1. </p>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; c1 = class1('blue')</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; c2 = class2('red')</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; c1.Hello1()</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">Hello from class1</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; c2.Hello2()</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">Hello from class2</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">7</font></p> </blockquote>  <p>Child class can access parent class methods</p>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; c2.Hello1() </font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">Hello from class1</font></p>    <p>The parent constructor called automatically for Childs, as following:</p> </blockquote>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; c1.printColor()</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">preferred blue</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&gt;&gt;&gt; c2.printColor()</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">preferred red</font></p> </blockquote>  <p>You can check for class methods, attributes using hasattr method:</p>  <blockquote>   <p><font color="#0000ff">if hasattr(class1, &quot;Hello2&quot;):</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; print c1.Hello2()</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">else:</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; print &quot;Class1 does not contain method Hello2()&quot;</font></p>    <p><font color="#0000ff">Class1 does not contain method Hello2()</font></p> </blockquote>  <p>To check the inheritance relation between two class :</p>  <blockquote>   <p><font color="#0000ff">if issubclass(class2, class1)</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160;&#160; Print &quot;Class2 is a subclass of Class1”</font></p> </blockquote>  <p>In this note we tried to cover as much as we can of the Python object oriented features. We give it a more advanced note in the future.</p>
