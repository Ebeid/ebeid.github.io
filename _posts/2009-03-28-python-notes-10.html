---
title: "Python Notes – 10 : Threading"
date: '2009-03-28T07:55:00.000-05:00'

tags:
- Python
modified_time: '2009-05-15T01:37:34.743-05:00'
blogger_id: tag:blogger.com,1999:blog-59384554657271185.post-7354092816140833782
blogger_orig_url: http://ebeid-soliman.blogspot.com/2009/03/python-notes-10.html
---

<p>Welcome to our tenth note in the Python learning process. In this note we will talk about threading, threads communication and synchronization.</p>  <h4>Threads basics</h4>  <p>A running program is called a &quot;process&quot;. Each process has memory, list of open files, stack, program counter, etc…. Normally, a process executes statements in a single sequence of control-flow. </p>  <p>The following commands create an entirely new process: fork(),system(), popen(), etc… This child process runs independently of the parent. Has own set of resources. There is minimal sharing of information between parent and child.</p>  <p>On the other side, a thread is kind of like a process (it’s a sequence of control-flow). Except that it exists entirely inside a process and shares resources. A single process may have multiple threads of execution. This is extremely useful when an application wants to perform many concurrent tasks on shared data.</p>  <h4>Problems with Threads</h4>  <ul>   <li>Scheduling : To execute a threaded program, must rapidly switch between threads. This can be done by the user process (user-level threads) or Can be done by the kernel (kernel-level threads). </li>    <li>Resource Sharing : Since threads share memory and other resources, you must be very careful. Operation performed in one thread could cause problems in another. </li>    <li>Synchronization : Threads often need to coordinate actions because they can get &quot;race conditions&quot; (outcome dependent on order of thread execution). You will often need to use locking primitives (mutual exclusion locks, semaphores, etc...) </li> </ul>  <h4>Python Threads</h4>  <p>Python supports threads on the following platforms : Solaris, Windows, systems that support the POSIX threads library (pthreads).</p>  <p>Thread scheduling is tightly controlled by a global interpreter lock and scheduler. Only a single thread is allowed to be executing in the Python interpreter at once. Thread switching only occurs between the execution of individual byte-codes. Long-running calculations in C/C++ can block execution of all other threads. However, most I/O operations do not block.</p>  <p>Python threads are somewhat more restrictive than in C. Effectiveness may be limited on multiple CPUs (due to interpreter lock). Threads can interact strangely with other Python modules (especially signal handling). Not all extension modules are thread-safe.</p>  <h4>The thread module</h4>  <p>The thread module provides low-level access to threads, thread creation, and Simple mutex locks.</p>  <h5>Creating a new thread</h5>  <p>Thread.start_new_thread(func,[args [,kwargs]]) Executes a function in a new thread. Syntax like:</p>  <blockquote>   <p><font color="#0000ff">import thread</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">import time</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">def print_time(delay):</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; while 1:</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; time.sleep(delay)</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; print time.ctime(time.time())</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">thread.start_new_thread(print_time,(5,))&#160;&#160;&#160;&#160;&#160; <font color="#0000ff"># Start the thread</font></font></p> </blockquote>  <blockquote>   <p><font color="#0000ff"># Go do something else</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">statements</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">…….</font></p> </blockquote>  <p>The function print_time will execute in a separate thread and will continue printing the time every 5 seconds. Python will continue executing our statements also.</p>  <h5>Thread termination</h5>  <p>Thread silently exits when the function returns. Thread can explicitly exit by calling thread.exit() or sys.exit(). Also uncaught exception causes thread termination (and prints error message).
Other threads continue to run even if one had an error.</p>  <h5>Simple locks</h5>  <p>allocate_lock(). Creates a lock object, initially unlocked. Only one thread can acquire the lock at once. Threads block indefinitely until lock becomes available.</p>  <blockquote>   <p><font color="#0000ff">import thread</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">lk = thread.allocate_lock()</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">def foo():</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; lk.acquire()&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; # Acquire the lock</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; …&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; #critical section</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; lk.release()&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; # Release the lock</font></p> </blockquote>  <p>You might use this if two or more threads were allowed to update a shared data structure.</p>  <h5>The main thread</h5>  <p>When Python starts, it runs as a single thread of execution. This is called the &quot;main thread.&quot; which is on its own and it’s not a big deal. However, if you launch other threads it has some special properties.</p>  <h5>Termination of the main thread</h5>  <p>If the main thread exits and other threads are active, the behavior is system dependent. Usually, this immediately terminates the execution of all other threads without cleanup. Cleanup actions of the main thread may be limited as well.</p>  <h5>Signal handling</h5>  <p>Signals can only be caught and handled by the main thread of execution. Otherwise you will get an error (in the signal module). The keyboard-interrupt can be caught by any thread (non-deterministically).</p>  <h4>The threading module</h4>  <p>The threading module is a high-level threads module that implements threads as classes (similar to Java). It provides an assortment of synchronization and locking primitives. It is built using the low-level thread module.</p>  <h5>Creating a new thread (as a class)</h5>  <p>When defining threads as classes all you need to supply is the following:</p>  <ol>   <li>A constructor that calls threading.Thread.__init__(self) </li>    <li>A run() method that performs the actual work of the thread. </li> </ol>  <p>A few additional methods are also available</p>  <ul>   <li><font color="#0000ff">t.join([timeout])&#160;&#160;&#160; # Wait for thread t to terminate</font> </li>    <li><font color="#0000ff">t.getName()&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; # Get the name of the thread</font> </li>    <li><font color="#0000ff">t.setName(name)&#160;&#160; # Set the name of the thread</font> </li>    <li><font color="#0000ff">t.isAlive()&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; # Return 1 if thread is alive.</font> </li>    <li><font color="#0000ff">t.isDaemon()&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; # Return daemonic flag</font> </li>    <li><font color="#0000ff">t.setDaemon(val)&#160;&#160; # Set daemonic flag</font> </li> </ul>  <p>Example: Inherit from the &quot;Thread&quot; class, provide required methods, and utilize the available methods.</p>  <blockquote>   <p><font color="#0000ff">import threading, time</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">class PrintTime(threading.Thread):</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; def __init__(self,interval):</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160;&#160;&#160;&#160;&#160; threading.Thread.__init__(self)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; # Required</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160;&#160;&#160;&#160;&#160; self.interval = interval</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; def run(sel
f):</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160;&#160;&#160;&#160;&#160; while 1:</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160;&#160;&#160;&#160;&#160; time.sleep(self.interval)&#160; </font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160;&#160;&#160;&#160;&#160; print time.ctime(time.time())</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">t = PrintTime(5)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; # Create a thread object</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">t.start()&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; # Start it</font></p> </blockquote>  <h5>Daemon threads</h5>  <p>Normally, interpreter exits only when all threads have terminated. However, a thread can be flagged as a daemon thread (runs in background). Interpreter really only exits when all non-daemonic threads exit. You can use this to launch threads that run forever, but which can be safely killed.</p>  <h4>Threads synchronization</h4>  <p>The threading module provides the following synchronization primitives:</p>  <ul>   <li>Mutual exclusion locks </li>    <li>Reentrant locks </li>    <li>Conditional variables </li>    <li>Semaphores </li>    <li>Events </li> </ul>  <p>When would you need these threads synchronization mechanisms ? </p>  <ul>   <li>When threads are updating shared data structures. </li>    <li>When threads need to coordinate their actions in some manner (events). </li> </ul>  <h5>The Lock object</h5>  <p>Provides a simple mutual exclusion lock. Only one thread is allowed to acquire the lock at once. Most useful for coordinating access to shared data.</p>  <blockquote>   <p><font color="#0000ff">import threading</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">data = [ ]&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; # Some data</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">lck = threading.Lock()&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; # Create a lock</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">def put_obj(obj):</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; lck.acquire()</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; data.append(obj)</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; lck.release()</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">def get_obj():</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; lck.acquire()</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; r = data.pop()</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; lck.release()</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; return r</font></p> </blockquote>  <h5>The RLock object</h5>  <p>A mutual-exclusion lock that allows repeated acquisition by the same thread. Allows nested acquire(), release() operations in the thread that owns the lock. Only the outermost release() operation actually releases the lock.</p>  <blockquote>   <p><font color="#0000ff">import threading</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">data = [ ]&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; # Some data</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">lck = threading.Lock()&#160; # Create a lock</font></p> </blo
ckquote>  <blockquote>   <p><font color="#0000ff">def put_obj(obj):</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; lck.acquire()</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; data.append(obj)</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; ...</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; put_obj(otherobj)&#160;&#160; # Some kind of recursion</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; ...</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; lck.release()</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">def get_obj():</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; lck.acquire()</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; r = data.pop()</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; lck.release()</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; return r</font></p> </blockquote>  <h5>The Condition object</h5>  <p>Creates a condition variable. Synchronization primitive typically used when a thread is interested in an event or state change. Could help in the producer-consumer classic problem.</p>  <blockquote>   <p><font color="#0000ff">data = []&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; # Create data queue and a condition variable</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">cv = threading.Condition()</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff"># Consumer thread</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">def consume_item():</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; cv.acquire()&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; # Acquire the lock</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; while not len(data):</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160;&#160;&#160;&#160;&#160; cv.wait()&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; # Wait for data to show up</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; r = data.pop()</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; cv.release()&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; # Release the lock</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; return r</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff"># Producer thread</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">def produce_item(obj):</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; cv.acquire()&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; # Acquire the lock</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; data.append(obj)</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; cv.notify()&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; # Notify a consumer</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; cv.release()&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; # Release the lock</font></p> </blockquote>  <h5>Semaphores</h5>  <p>A locking primitive based on a counter. Each acquire() method decrements the counter. Each release() method increments the counter. If the counter reaches zero, future acquire() methods block. Common use: limiting the number of threads allowed to execute code</p>  <blockquote>   <p><font color="#0000ff">sem = threading.Semaphore(5)&#160;&#160;&#160;&#160;&#160; # No more than 5 threads allowed</font></p> </blockquote>  <
blockquote>   <p><font color="#0000ff">def fetch_file(host,filename):</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; sem.acquire()&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; # Decrements count or blocks if zero</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; ...</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; sem.release()&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; # Increment count</font></p> </blockquote>  <h5>Events</h5>  <p>A communication primitive for coordinating threads. One thread signals an &quot;event&quot; while other threads wait for it to happen.</p>  <blockquote>   <p><font color="#0000ff">e = Event()&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <font color="#0000ff"># Create an event object</font></font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">def signal_event():&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <font color="#0000ff"># Signal the event</font></font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160;&#160; e.set()</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">def wait_for_event():&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; # Wait for event</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; e.wait()</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">def clear_event():&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; <font color="#0000ff"># Clear event</font></font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160; e.clear()</font></p> </blockquote>  <p>Event is similar to a condition variable, but all threads waiting for event are awakened.</p>  <h5>Locks and Blocking</h5>  <p>By default, all locking primitives block until lock is acquired. In general, this is uninterruptible. Fortunately, most primitives provide a non-blocking option</p>  <blockquote>   <p><font color="#0000ff">if not lck.acquire(0):</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">&#160;&#160;&#160;&#160; # lock couldn’t be acquired!</font></p> </blockquote>  <p>This works for Lock, RLock, and Semaphore objects. On the other hand condition variables and events provide a timeout option</p>  <blockquote>   <p><font color="#0000ff">cv = Condition()</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">...</font></p> </blockquote>  <blockquote>   <p><font color="#0000ff">cv.wait(60.0)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; # Wait 60 seconds for notification</font></p> </blockquote>  <p>On timeout, the function simply returns. Up to caller to detect errors.</p>  <h4>The Queue Module</h4>  <p>Provides a multi-producer, multi-consumer FIFO queue object. It can be used to safely exchange data between multiple threads.</p>  <ul>   <li><font color="#0000ff">q = Queue(maxsize)&#160;&#160;&#160; # Create a queue.</font> </li>    <li><font color="#0000ff">q.qsize()&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; # Return current size.</font> </li>    <li><font color="#0000ff">q.empty()&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; # Test if empty.</font> </li>    <li><font color="#0000ff">q.full()&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; # Test if full.</font> </li>    <li><font color="#0000ff">q.put(item)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; # Put an item on the queue.</font> </li>    <li><font color="#0000ff">q.get()&#160;&#1
60;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; # Get item from queue</font> </li> </ul>  <p>The Queue object also supports non-blocking put/get.</p>  <ul>   <li><font color="#0000ff">q.put_nowait(item).</font> </li>    <li><font color="#0000ff">q.get_nowait()</font> </li> </ul>  <p>These raise the Queue.Full or Queue.Empty exceptions if an error occurs. Return values for qsize(), empty(), and full() are approximate.</p>  <h4>Things to consider when using threads</h4>  <ul>   <li>Global interpreter lock makes it difficult to fully utilize multiple CPUs. </li>    <li>You don’t get the degree of parallelism you might expect. </li>    <li>Not all modules are thread-friendly. Example: gethostbyname() blocks all threads if nameserver down. </li> </ul>  <p>In this note we will talked about threading, threads communication and synchronization. In the upcoming notes, we will talk about more advanced topics in Python programming.</p>
