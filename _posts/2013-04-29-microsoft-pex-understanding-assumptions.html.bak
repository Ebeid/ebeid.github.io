---
title: 'Microsoft Pex: Understanding Assumptions, Assertions, and Test-Case Failures'
date: '2013-04-29T15:00:00.000-05:00'
author: Ebeid Soliman ElSayed
tags:
- Microsoft Pex
modified_time: '2013-04-28T16:01:25.139-05:00'
thumbnail: http://lh4.ggpht.com/-E1BV--ea4YU/UXmnznj8UkI/AAAAAAAABLE/_L5VZaVypYs/s72-c/ConsoleApplication2%252520-%252520Microsoft%252520Visual%252520Studio_2013-04-24_15-46-30_thumb%25255B2%25255D.jpg?imgmax=800
blogger_id: tag:blogger.com,1999:blog-59384554657271185.post-6691406490897728526
blogger_orig_url: http://ebeid-soliman.blogspot.com/2013/04/microsoft-pex-understanding-assumptions.html
---

<p>In a previous post we started using Microsoft Pex and showed how it helped exploring all possible code paths, and how that helped discovering a defect in our program logic. In that example, even our program logic is defective, all test cases succeeded. A test case fails if there is an un-caught exception or a failed assertion.</p> <p>To see an example of a failed test case and how Pex could help in fixing it, let’s add the following basic function to our code:</p><pre class="prettyprint lang-cs">public void Add(ArrayList a, object o)<br />        {<br />            a.Add(o);<br />        }<br /></pre><br /><p>when you run Pex for that simple method, you get the following results:</p><br /><p><a href="http://lh3.ggpht.com/-Thkc7tlIHdY/UXmnzD-F23I/AAAAAAAABK8/0xbEpUghC58/s1600-h/ConsoleApplication2%252520-%252520Microsoft%252520Visual%252520Studio_2013-04-24_15-46-30%25255B4%25255D.jpg"><img style="background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px" title="ConsoleApplication2 - Microsoft Visual Studio_2013-04-24_15-46-30" border="0" alt="ConsoleApplication2 - Microsoft Visual Studio_2013-04-24_15-46-30" src="http://lh4.ggpht.com/-E1BV--ea4YU/UXmnznj8UkI/AAAAAAAABLE/_L5VZaVypYs/ConsoleApplication2%252520-%252520Microsoft%252520Visual%252520Studio_2013-04-24_15-46-30_thumb%25255B2%25255D.jpg?imgmax=800" width="727" height="134"></a></p><br /><p>As you might expected, the ArrayList object might be NULL. In situations similar to this one, when a higher-level component (the code that called Add() method) passes malformed data to a lower-level component(that Add() method), which the lower-level component rejects, then the higher-level component should be prevented from doing so in the first place.</p><br /><p>One way to achieve this is to promote the failure condition of the lower-level component to the abstraction level of the higher-level component. This is what the <u>Add Precondition</u> feature of Pex does: It expresses a low-level failure condition at the abstraction level of the code under test. When added to the code-under-test as argument validation code—also called a precondition—then this effectively prevents the code under test from causing a failure somewhere in its execution. In other words, the Add Precondition feature doesn’t completely fix an error, but it promotes the failure condition to a higher, more appropriate abstraction level.</p><br /><p>To add a precondition to your code, click the failed test case row, then on the details section (right) click <u>Add Precondition</u>, as in picture below</p><br /><p><a href="http://lh5.ggpht.com/-EcW7YsvnRFA/UXmnz9bgwMI/AAAAAAAABLM/9I2Slcoh6iA/s1600-h/002%252520-%252520200%252520-%252520Exploring%252520Code%252520with%252520Microsoft%252520Pex.docx%252520%25255BCompatibility%252520Mode%25255D%252520-%252520Word_2013-04-25_08-56-05%25255B4%25255D.jpg"><img style="background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px" title="002 - 200 - Exploring Code with Microsoft Pex.docx [Compatibility Mode] - Word_2013-04-25_08-56-05" border="0" alt="002 - 200 - Exploring Code with Microsoft Pex.docx [Compatibility Mode] - Word_2013-04-25_08-56-05" src="http://lh5.ggpht.com/-TOCaWmxTeQA/UXmn0PHPulI/AAAAAAAABLQ/7nxDventpME/002%252520-%252520200%252520-%252520Exploring%252520Code%252520with%252520Microsoft%252520Pex.docx%252520%25255BCompatibility%252520Mode%25255D%252520-%252520Word_2013-04-25_08-56-05_thumb%25255B2%25255D.jpg?imgmax=800" width="581" height="392"></a></p><br /><p>Pex will open <u>Preview and Apply updates</u> dialog box to show you the proposed code modifications that Pex will do. </p><br /><p><a href="http://lh4.ggpht.com/-4gCSpnuh2dw/UXmn0Trx99I/AAAAAAAABLc/ILN7OVMFba8/s1600-h/Preview%252520and%252520Apply%252520updates_2013-04-25_09-00-24%25255B3%25255D.jpg"><img style="background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px" title="Preview and Apply updates_2013-04-25_09-00-24" border="0" alt="Preview and Apply updates_2013-04-25_09-00-24" src="http://lh4.ggpht.com/-0ZJJTu76gyI/UXmn0ygH80I/AAAAAAAABLk/1s3XMMG4eU8/Preview%252520and%252520Apply%252520updates_2013-04-25_09-00-24_thumb%25255B1%25255D.jpg?imgmax=800" width="480" height="311"></a></p><br /><p>Review and Click <u>Apply</u>. The modified method will look like:</p><pre class="prettyprint lang-cs">        <br />public void Add(ArrayList a, object o)<br />        {<br />            // <pex><br />            Debug.Assert(a != (ArrayList)null, "a");<br />            // </pex><br />            a.Add(o);<br />        }<br /></pre><br /><p>When you run Pex for our method now, we will not find a failed test case. </p><br /><p>The concept of assertions is well known in unit test frameworks. Pex understands the built-in Assert classes provided by each supported test framework. However, most frameworks do not provide a corresponding Assume class as Pex did. <strong><a href="http://research.microsoft.com/en-us/um/redmond/projects/pex/wiki/pexassume.html" target="_blank">PexAssume</a></strong> is a class to express assumptions, i.e. a precondition. The methods of this class can be used to filter out undesirable test inputs. If you do not want to use an existing test framework, Pex also has the <a href="http://research.microsoft.com/en-us/um/redmond/projects/pex/wiki/PexAssert.html" target="_blank">PexAssert</a> class. Some functionalities can be achieved using attributes instead of PexAssume methods, like <strong><a href="http://research.microsoft.com/en-us/um/redmond/projects/pex/wiki/PexAssumeNotNullAttribute.html" target="_blank">PexAssumeNotNullAttribute</a></strong> and <a href="http://research.microsoft.com/en-us/um/redmond/projects/pex/wiki/PexAssumeUnderTestAttribute.html" target="_blank"><strong>PexAssumeUnderTestAttribute</strong></a>.<strong> </strong></p><pre class="prettyprint lang-cs"> <br />[PexMethod]<br />public void Test1(object o)  //precondition: o should not be null<br />{<br /> PexAssume.IsNotNull(o);<br /> ...<br />}<br /><br />[PexMethod]<br />public void Test2([PexAssumeNotNull]object o) //precondition: o should not be null<br />{ <br /> ...<br />}<br /></pre><br /><p>When you write an assertion, Pex will not only passively detect assertion violations, but Pex will in fact actively try to compute test inputs that will cause the assertion to fail (just as an assertion might throw a <strong>PexAssertFailedException</strong>). Pes uses these exceptions internally to stop a test case when an assumption fails.</p><br /><h3>Expected Exceptions</h3><br /><p>You can annotate the test—or the test class, or the test assembly—with one of the following attributes to indicate which exception types can or must be thrown by the test in order to be considered successful: <br /><ul><br /><li><strong>PexAllowedExceptionAttribute</strong> indicates that a test method, or any other method that it calls directly or indirectly, can throw a particular type of exception for some test inputs. <pre class="prettyprint lang-cs">using System;<br />using Microsoft.Pex.Framework;<br />using Microsoft.Pex.Framework.Validation;<br /><br />namespace ConsoleApplication3<br />{<br />    class Stack<br />    {<br />        int[] _elements;<br />        int _count;<br />        public Stack(int capacity)<br />        {<br />            if (capacity &lt; 0) throw new ArgumentOutOfRangeException();<br />            _elements = new int[capacity];<br />            _count = 0;<br />        }<br />    }<br /><br />    [PexClass]<br />    public partial class StackTest<br />    {<br />        [PexMethod]<br />        [PexAllowedException(typeof(ArgumentOutOfRangeException))]<br />        public void CtorTest(int capacity) // will not fail<br />        {<br />            Stack s = new Stack(capacity); // may throw ArgumentOutOfRangeException<br />        }<br />    }<br />}<br /></pre><br /><li><strong>PexAllowedExceptionFromTypeAttribute</strong> indicates that any method of a specified type can throw a particular type of exception for some test inputs. <pre class="prettyprint lang-cs">using System;<br />using System.Collections;<br />using Microsoft.Pex.Framework;<br />using Microsoft.Pex.Framework.Validation;<br /><br />namespace ConsoleApplication3<br />{<br />    [PexClass]<br />    public partial class ArrayListTest<br />    {<br />        [PexMethod]<br />        [PexAllowedExceptionFromType(typeof(NullReferenceException), typeof(ArrayListTest))]<br />        public void Add1(ArrayList a, object o) //will not fail<br />        {<br />            a.Add(o);<br />        }<br />    }<br />}<br /></pre><br /><li><strong>PexAllowedExceptionFromTypeUnderTestAttribute</strong> indicates that any method of the designated type under test can throw a particular type of exception for some test inputs. <br /><li><strong>PexAllowedExceptionFromAssemblyAttribute</strong> indicates that any method located in a specified assembly can throw a particular type of exception for some test inputs.</li></ul><br /><h3><a name="_Toc255301736">When Does Pex Emit a Test Case?</a></h3><br /><p>Pex supports different filters that decide when generated test inputs will be emitted as a test case. You can configure these filters with the <strong><a href="http://research.microsoft.com/en-us/um/redmond/projects/pex/wiki/TestEmissionFilter.html" target="_blank">TestEmissionFilter</a></strong> property that you can set for example in the <strong>PexMethod</strong> attribute. Possible values are the following:</p><br /><ul><br /><li><strong>All</strong> Emit every generated test input as a test case, including those that cause assumption violations. <br /><li><strong>FailuresAndIncreasedBranchHits</strong> (<font color="#ff0000"><u>default</u></font>) Emit tests for all unique failures, and whenever a test case increases coverage, as controlled by the TestEmissionBranchHits property (take values 1 or 2). <br /><li><strong>FailuresAndUniquePaths</strong> Emit tests for all failures Pex finds, and also for each test input that causes a unique execution path. <br /><li><strong>Failures</strong> Emit tests for failures only.</li></ul><br /><p>Regarding increased branch coverage, the TestEmissionBranchHits property controls how a branch is covered. For example: <br /><ul><br /><li><strong>TestEmissionBranchHits=1</strong>: Whether Pex should just consider whether a branch was covered at all. This gives a very small test suite that covers all branches Pex could reach. In particular, this test suite also covers all reached basic blocks and statements. <br /><li><strong>TestEmissionBranchHits=2</strong>: Whether a test covered it either once or twice.</li></ul><br /><p>The default is TestEmissionBranchHits=2, which generates a more expressive test suite that is also better suited to detect future regression errors. <pre class="prettyprint lang-cs">using System;<br />using Microsoft.Pex.Framework;<br />using Microsoft.Pex.Framework.Settings;<br /><br />namespace ConsoleApplication3<br />{<br />    [PexClass]<br />    partial class TestEmission<br />    {<br />        int max(int x, int y)<br />        {<br />            if (x &gt; y)<br />                return x;<br />            else<br />                return y;<br />        }<br /><br />        [PexMethod(TestEmissionFilter=Microsoft.Pex.Framework.Settings.PexTestEmissionFilter.All)]<br />        public void MaxTest1(int a, int b, int c, int d)    // 1 test case generated<br />        {<br />            int e = max(a, b);<br />            PexObserve.ValueForViewing("max", e);<br />        }<br /><br />        [PexMethod(TestEmissionFilter = Microsoft.Pex.Framework.Settings.PexTestEmissionFilter.Failures)]<br />        public void MaxTest2(int a, int b, int c, int d)    // No test cases generated <br />        {<br />            int e = max(a, b);<br />            PexObserve.ValueForViewing("max", e);<br />        }<br />    }<br />}<br /></pre><br /><h3>When Does Pex Stop ? </h3><br /><p>If the code under test does not contain loops or unbounded recursion, Pex will typically stop quickly because there is only a (small) finite number of execution paths to analyze. However, most interesting programs contain loops and/or unbounded recursion. In such cases the number of execution paths is (practically) infinite, and it is in general undecidable whether a statement is reachable. In other words, Pex would take forever to analyze all execution paths of the program. <br /><p>In order to make sure that Pex terminates after a reasonable amount of time, there are several exploration bounds. All bounds have predefined default values, which you can override to let Pex analyze more and longer execution paths. The bounds are parameters of the PexMethod, PexClass, and PexAssemblySettings attributes. There are different kinds of bounds: <br /><ul><br /><li><strong>Constraint Solving Bounds:</strong> apply to each attempt of Pex to determine whether an execution path is feasible or not. Pex might need several constraint solving attempts to compute the next test inputs. <br /><ul><br /><li><strong>ConstraintSolverTimeOut</strong> Seconds the constraint solver has to figure out inputs that will cause a different execution path to be taken. <br /><li><strong>ConstraintSolverMemoryLimit</strong> Megabytes the constraint solver can use to figure out inputs.</li></ul><br /><li><strong>Exploration Path Bounds:</strong> apply to each execution path that Pex executes and monitors. These bounds make sure that the program does not get stuck in an infinite loop, or recursive method. <br /><ul><br /><li><strong>MaxBranches</strong> Maximum number of branches that can be taken along a single execution path. <br /><li><strong>MaxCalls</strong> Maximum number of calls that can be taken during a single execution path. <br /><li><strong>MaxStack</strong> Maximum size of the stack at any time during a single execution path, measured in number of active call frames. <br /><li><strong>MaxConditions</strong> Maximum number of conditions over the inputs that can be checked during a single execution path.</li></ul><br /><li><strong>Exploration Bounds</strong> apply to the exploration of each parameterized unit test. <br /><ul><br /><li><strong>MaxRuns</strong> Maximum number of runs that will be tried during an exploration (each run uses different test inputs; not every run will result in the emission of a new test case). <br /><li><strong>MaxRunsWithoutNewTests </strong>Maximum number of consecutive runs without a new test being emitted. <br /><li><strong>MaxRunsWithUniquePaths </strong>Maximum number of runs with unique execution paths that will be tried during an exploration. <br /><li><strong>MaxExceptions</strong> Maximum number of exceptions that can be found over all discovered execution paths combined. <br /><li><strong>MaxExecutionTreeNodes</strong> Maximum number of conditions over the inputs that can be checked during all discovered execution paths combined. <br /><li><strong>MaxWorkingSet</strong> Maximum size of working set in megabytes. <br /><li><strong>TimeOut</strong> Seconds after which exploration stops.</li></ul></li></ul><br /><p>The following example shows a parameterized test that involves a loop. The loop bound depends on the test inputs, and the exception can only be triggered if the loop is executed a certain number of times. Here, we used an explicit bound of 10 runs <em>MaxRuns=10 </em>to let Pex finish quickly. However, with this bound, Pex will most likely not be able to trigger the exception, as Pex will not unroll the loop sufficiently many times:</p><pre class="prettyprint lang-cs"> [PexMethod(MaxRuns = 10)]<br />        public void TestWithLoop(int n)<br />        {<br />            var sum = 0;<br />            for (int i = 0; i &lt; n; i++)<br />                sum++;<br />            if (sum &gt; 20) throw new Exception();<br />        } <br /> </pre><br /><p>In the Pex Exploration Results you may see the Exception statement reached, but you will see on the Pex tool bar that there is 1 boundry reached. <a href="http://lh5.ggpht.com/-0iqrQSiM5YA/UX2LfVAqpKI/AAAAAAAABL0/lRqob2u4m4E/s1600-h/ConsoleApplication2%252520-%252520Microsoft%252520Visual%252520Studio_2013-04-28_15-01-11%25255B2%25255D.jpg"><img style="background-image: none; border-right-width: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px" title="ConsoleApplication2 - Microsoft Visual Studio_2013-04-28_15-01-11" border="0" alt="ConsoleApplication2 - Microsoft Visual Studio_2013-04-28_15-01-11" src="http://lh4.ggpht.com/-RJa9gQF3pDc/UX2Lf5BPsjI/AAAAAAAABL8/JeGP2MuNJLs/ConsoleApplication2%252520-%252520Microsoft%252520Visual%252520Studio_2013-04-28_15-01-11_thumb.jpg?imgmax=800" width="180" height="86"></a> If you click on it, you will see more details:<br><a href="http://lh5.ggpht.com/-DPXDqCCgi7Y/UX2LgUw2_nI/AAAAAAAABME/iioNUjn44bU/s1600-h/ConsoleApplication2%252520-%252520Microsoft%252520Visual%252520Studio_2013-04-28_15-04-15%25255B3%25255D.jpg"><img style="background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px" title="ConsoleApplication2 - Microsoft Visual Studio_2013-04-28_15-04-15" border="0" alt="ConsoleApplication2 - Microsoft Visual Studio_2013-04-28_15-04-15" src="http://lh5.ggpht.com/-wzeFFSVgpvI/UX2LgvZFNiI/AAAAAAAABMM/pN9z39kW7ww/ConsoleApplication2%252520-%252520Microsoft%252520Visual%252520Studio_2013-04-28_15-04-15_thumb%25255B1%25255D.jpg?imgmax=800" width="601" height="238"></a><br>on the right, you could click Set MaxRuns=20 to increase the MaxRuns boundry. You could do the same from the Pex tool bar <a href="http://lh6.ggpht.com/-MCZ8WSEiR3I/UX2Lg8fB4pI/AAAAAAAABMU/XktXEpPIS1Q/s1600-h/ConsoleApplication2%252520-%252520Microsoft%252520Visual%252520Studio_2013-04-28_15-15-32%25255B2%25255D.jpg"><img style="background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px" title="ConsoleApplication2 - Microsoft Visual Studio_2013-04-28_15-15-32" border="0" alt="ConsoleApplication2 - Microsoft Visual Studio_2013-04-28_15-15-32" src="http://lh6.ggpht.com/-euiHnSSQO0E/UX2LhbrfH2I/AAAAAAAABMc/f8552av2JcU/ConsoleApplication2%252520-%252520Microsoft%252520Visual%252520Studio_2013-04-28_15-15-32_thumb.jpg?imgmax=800" width="220" height="91"></a> and also setting boundary to infinity. Both actions will open a dialog to review and approve the code changes. <br /><p>The following example shows another parameterized test that involves a loop, but this loop does not depend on the test inputs. Here, we used an explicit bound of 10 branches <em>MaxBranches=10</em> to let Pex finish quickly. However, with this bound, Pex cannot even once execute the code from beginning to end, as executing the embedded loop will cause more than 10 branches to be executed.</p><pre class="prettyprint lang-cs"> [PexMethod(MaxBranches = 10)]<br />        public void TestWithFixedLoop(int j)<br />        {<br />            var sum = 0;<br />            for (int i = 0; i &lt; 15; i++)<br />                sum++;<br />            if (j == 10) throw new Exception();<br />        }<br /> </pre><br /><p>In those cases, where a particular run exceeded some path-specific bounds, we get a special row in the results. <a href="http://lh4.ggpht.com/-fwJAgIRmwSo/UX2LiGNixiI/AAAAAAAABMk/FyQjO98JQY8/s1600-h/ConsoleApplication2%252520-%252520Microsoft%252520Visual%252520Studio_2013-04-28_15-28-43%25255B2%25255D.jpg"><img style="background-image: none; border-right-width: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px" title="ConsoleApplication2 - Microsoft Visual Studio_2013-04-28_15-28-43" border="0" alt="ConsoleApplication2 - Microsoft Visual Studio_2013-04-28_15-28-43" src="http://lh4.ggpht.com/-PKx0DnVshnA/UX2LiqngnvI/AAAAAAAABMs/s9v5yC1gxQg/ConsoleApplication2%252520-%252520Microsoft%252520Visual%252520Studio_2013-04-28_15-28-43_thumb.jpg?imgmax=800" width="216" height="51"></a> The Set MaxBranches= button on the results tool can be used to increase the bounds.<a href="http://lh5.ggpht.com/-Bfkv7dGSqmY/UX2LjMa__eI/AAAAAAAABM0/grYBR-3zTTM/s1600-h/ConsoleApplication2%252520-%252520Microsoft%252520Visual%252520Studio_2013-04-28_15-31-57%25255B2%25255D.jpg"><img style="background-image: none; border-bottom: 0px; border-left: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px" title="ConsoleApplication2 - Microsoft Visual Studio_2013-04-28_15-31-57" border="0" alt="ConsoleApplication2 - Microsoft Visual Studio_2013-04-28_15-31-57" src="http://lh6.ggpht.com/-NG-jK1X2X2c/UX2LjaTfhHI/AAAAAAAABM8/-LgjASHxojQ/ConsoleApplication2%252520-%252520Microsoft%252520Visual%252520Studio_2013-04-28_15-31-57_thumb.jpg?imgmax=800" width="229" height="94"></a> If you increased the boundary to 20, you will get all you branched executed and the exception statement reached.<br /><p>In this post we talked about how and when a test case fail, how to use precondition and assumptions to differentiate between failures from your unit code and failures from malformed input, how to allow specific exception to be raised from your tests without causing it to fail, how to control which test inputs should Pex use as a test case, and finally how to control the Pex stop criteria whether through&nbsp; bounding the constraint solver, or bounding the exploration paths, or bounding the exploration runs.</p>
