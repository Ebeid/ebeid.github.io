
<!DOCTYPE html>
<html lang="en">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<meta http-equiv="X-UA-Compatible" content="ie=edge"/>
<meta name="theme-color" content="#478079" >



<title>Ebeid ElSayed | Product Manager</title>
<meta name="description" content='Ebeid ElSayed | Product Manager | Personal Site.'>


<style data-generator="critical-css">

</style>



    
        
        
    

    
        
        
    

    
        
        
    

  
  
  
  
  <link rel="stylesheet" href="http://localhost:1313/css/menu.6e233ea8020133c8fdf840fc9876a529cacbe674c7d8193cc12963d7eb29f253.css" integrity="sha256-biM&#43;qAIBM8j9&#43;ED8mHalKcrL5nTH2Bk8wSlj1&#43;sp8lM=">







 


<link
  rel="preload"
  href="/css/bundle.css"
  as="style"
  data-generator="purgeCSS"
  onload="this.onload=null;this.rel='stylesheet'"
  
/>
<noscript>
  <link 
    rel="stylesheet" 
    href="/css/bundle.css"
    
  />
</noscript>



<script src='http://localhost:1313/js/library/lozad.min.js'></script>

 

  </head>

  <body>
    

<header class="header fixed-top rad-animation-group" id="header">
  <div class="container rad-fade-in">
    <nav class="navbar navbar-expand-lg navbar-light p-0">
      <div class="container-fluid">
        <a class="navbar-brand mx-auto" href="http://localhost:1313/">
          <span>Ebeid</span>
          <span>ElSayed</span>
        </a>
        <button
          class="navbar-toggler collapsed"
          type="button"
          data-bs-toggle="collapse"
          data-bs-target="#navbarSupportedContent, #header"
          aria-controls="navbarSupportedContent"
          aria-expanded="false"
          aria-label="Toggle navigation"
        >
          <span class="navbar-toggler-icon"></span>
        </button>
        <div class="collapse navbar-collapse" id="navbarSupportedContent">
          <ul class="navbar-nav ml-lg-auto">
            <li class="nav-item">
              <a class="nav-link active" href="http://localhost:1313/">HOME</a>
            </li>
            
            <li class="nav-item">
              <a data-scroll class="nav-link" href="/#about"
                >ABOUT</a
              >
            </li>
            
            <li class="nav-item">
              <a data-scroll class="nav-link" href="/#experience"
                >EXPERIENCE</a
              >
            </li>
            
            <li class="nav-item">
              <a data-scroll class="nav-link" href="/blog"
                >BLOG</a
              >
            </li>
            
            <li class="nav-item">
              <a data-scroll class="nav-link" href="/#contact"
                >CONTACT</a
              >
            </li>
            
          </ul>
        </div>
      </div>
    </nav>
  </div>
</header>


<section id="breadcrumb-bar" class="breadcrumb-bar container">
        <ul class="breadcrumbs">
            <li class="breadcrum-item"><span><a href="/">Home</a></span></li><li class="breadcrum-item"><span><a href="/2009">2009th</a></span></li><li class="breadcrum-item"><span><a href="/2009/03">3rd</a></span></li><li class="breadcrum-item"><span><a href="/2009/03/python-notes-10.html">Python notes 10.html</a></span></li></ul>
</section>


    <section
      id="blog-single"
      class="section section--border-bottom rad-animation-group"
    >
      <div class="container">
        <h1><a href="/2009/03/python-notes-10.html">Python Notes â€“ 10 : Threading</a></h1>

        <aside id="meta" class="light-border-bottom">
          <div>
            <section>
              Published en
              <h4 id="date">Sat Mar 28, 2009</h4>
              Â·
              <h4 id="wordcount">1490 Words</h4>
            </section>
             
            <ul id="tags">
              
              <li><a href="/tags/python/">Python</a></li>
              
            </ul>
            
          </div>
        </aside>

        <div class="row flex-column-reverse flex-md-row rad-fade-down">
          <div class="col-12"><p>Welcome to our tenth note in the Python learning process. In this note we will talk about threading, threads communication and synchronization.</p>
<h4 id="threads-basics">Threads basics</h4>
<p>A running program is called a &ldquo;process&rdquo;. Each process has memory, list of open files, stack, program counter, etcâ€¦. Normally, a process executes statements in a single sequence of control-flow.</p>
<p>The following commands create an entirely new process: fork(),system(), popen(), etcâ€¦ This child process runs independently of the parent. Has own set of resources. There is minimal sharing of information between parent and child.</p>
<p>On the other side, a thread is kind of like a process (itâ€™s a sequence of control-flow). Except that it exists entirely inside a process and shares resources. A single process may have multiple threads of execution. This is extremely useful when an application wants to perform many concurrent tasks on shared data.</p>
<h4 id="problems-with-threads">Problems with Threads</h4>
<ul>
<li>Scheduling : To execute a threaded program, must rapidly switch between threads. This can be done by the user process (user-level threads) or Can be done by the kernel (kernel-level threads).</li>
<li>Resource Sharing : Since threads share memory and other resources, you must be very careful. Operation performed in one thread could cause problems in another.</li>
<li>Synchronization : Threads often need to coordinate actions because they can get &ldquo;race conditions&rdquo; (outcome dependent on order of thread execution). You will often need to use locking primitives (mutual exclusion locks, semaphores, etc&hellip;)</li>
</ul>
<h4 id="python-threads">Python Threads</h4>
<p>Python supports threads on the following platforms : Solaris, Windows, systems that support the POSIX threads library (pthreads).</p>
<p>Thread scheduling is tightly controlled by a global interpreter lock and scheduler. Only a single thread is allowed to be executing in the Python interpreter at once. Thread switching only occurs between the execution of individual byte-codes. Long-running calculations in C/C++ can block execution of all other threads. However, most I/O operations do not block.</p>
<p>Python threads are somewhat more restrictive than in C. Effectiveness may be limited on multiple CPUs (due to interpreter lock). Threads can interact strangely with other Python modules (especially signal handling). Not all extension modules are thread-safe.</p>
<h4 id="the-thread-module">The thread module</h4>
<p>The thread module provides low-level access to threads, thread creation, and Simple mutex locks.</p>
<h5 id="creating-a-new-thread">Creating a new thread</h5>
<p>Thread.start_new_thread(func,[args [,kwargs]]) Executes a function in a new thread. Syntax like:</p>
<blockquote>
<p>import thread</p>
</blockquote>
<blockquote>
<p>import time</p>
</blockquote>
<blockquote>
<p>def print_time(delay):</p>
</blockquote>
<blockquote>
<p>Â Â Â  while 1:</p>
</blockquote>
<blockquote>
<p>Â Â Â  time.sleep(delay)</p>
</blockquote>
<blockquote>
<p>Â Â Â  print time.ctime(time.time())</p>
</blockquote>
<blockquote>
<p>thread.start_new_thread(print_time,(5,))Â Â Â Â Â  # Start the thread</p>
</blockquote>
<blockquote>
<p># Go do something else</p>
</blockquote>
<blockquote>
<p>statements</p>
</blockquote>
<blockquote>
<p>â€¦â€¦.</p>
</blockquote>
<p>The function print_time will execute in a separate thread and will continue printing the time every 5 seconds. Python will continue executing our statements also.</p>
<h5 id="thread-termination">Thread termination</h5>
<p>Thread silently exits when the function returns. Thread can explicitly exit by calling thread.exit() or sys.exit(). Also uncaught exception causes thread termination (and prints error message). Other threads continue to run even if one had an error.</p>
<h5 id="simple-locks">Simple locks</h5>
<p>allocate_lock(). Creates a lock object, initially unlocked. Only one thread can acquire the lock at once. Threads block indefinitely until lock becomes available.</p>
<blockquote>
<p>import thread</p>
</blockquote>
<blockquote>
<p>lk = thread.allocate_lock()</p>
</blockquote>
<blockquote>
<p>def foo():</p>
</blockquote>
<blockquote>
<p>Â Â Â  lk.acquire()Â Â Â Â Â Â Â Â  # Acquire the lock</p>
</blockquote>
<blockquote>
<p>Â Â Â  â€¦Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  #critical section</p>
</blockquote>
<blockquote>
<p>Â Â Â  lk.release()Â Â Â Â Â Â Â Â  # Release the lock</p>
</blockquote>
<p>You might use this if two or more threads were allowed to update a shared data structure.</p>
<h5 id="the-main-thread">The main thread</h5>
<p>When Python starts, it runs as a single thread of execution. This is called the &ldquo;main thread.&rdquo; which is on its own and itâ€™s not a big deal. However, if you launch other threads it has some special properties.</p>
<h5 id="termination-of-the-main-thread">Termination of the main thread</h5>
<p>If the main thread exits and other threads are active, the behavior is system dependent. Usually, this immediately terminates the execution of all other threads without cleanup. Cleanup actions of the main thread may be limited as well.</p>
<h5 id="signal-handling">Signal handling</h5>
<p>Signals can only be caught and handled by the main thread of execution. Otherwise you will get an error (in the signal module). The keyboard-interrupt can be caught by any thread (non-deterministically).</p>
<h4 id="the-threading-module">The threading module</h4>
<p>The threading module is a high-level threads module that implements threads as classes (similar to Java). It provides an assortment of synchronization and locking primitives. It is built using the low-level thread module.</p>
<h5 id="creating-a-new-thread-as-a-class">Creating a new thread (as a class)</h5>
<p>When defining threads as classes all you need to supply is the following:</p>
<ol>
<li>A constructor that calls threading.Thread.__init__(self)</li>
<li>A run() method that performs the actual work of the thread.</li>
</ol>
<p>A few additional methods are also available</p>
<ul>
<li>t.join([timeout])Â Â Â  # Wait for thread t to terminate</li>
<li>t.getName()Â Â Â Â Â Â Â Â Â  # Get the name of the thread</li>
<li>t.setName(name)Â Â  # Set the name of the thread</li>
<li>t.isAlive()Â Â Â Â Â Â Â Â Â Â Â Â  # Return 1 if thread is alive.</li>
<li>t.isDaemon()Â Â Â Â Â Â Â Â  # Return daemonic flag</li>
<li>t.setDaemon(val)Â Â  # Set daemonic flag</li>
</ul>
<p>Example: Inherit from the &ldquo;Thread&rdquo; class, provide required methods, and utilize the available methods.</p>
<blockquote>
<p>import threading, time</p>
</blockquote>
<blockquote>
<p>class PrintTime(threading.Thread):</p>
</blockquote>
<blockquote>
<p>Â Â Â  def __init__(self,interval):</p>
</blockquote>
<blockquote>
<p>Â Â Â Â Â Â Â  threading.Thread.__init__(self)Â Â Â Â Â Â Â Â  # Required</p>
</blockquote>
<blockquote>
<p>Â Â Â Â Â Â Â  self.interval = interval</p>
</blockquote>
<blockquote>
<p>Â Â Â  def run(self):</p>
</blockquote>
<blockquote>
<p>Â Â Â Â Â Â Â  while 1:</p>
</blockquote>
<blockquote>
<p>Â Â Â Â Â Â Â  time.sleep(self.interval)Â </p>
</blockquote>
<blockquote>
<p>Â Â Â Â Â Â Â  print time.ctime(time.time())</p>
</blockquote>
<blockquote>
<p>t = PrintTime(5)Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  # Create a thread object</p>
</blockquote>
<blockquote>
<p>t.start()Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  # Start it</p>
</blockquote>
<h5 id="daemon-threads">Daemon threads</h5>
<p>Normally, interpreter exits only when all threads have terminated. However, a thread can be flagged as a daemon thread (runs in background). Interpreter really only exits when all non-daemonic threads exit. You can use this to launch threads that run forever, but which can be safely killed.</p>
<h4 id="threads-synchronization">Threads synchronization</h4>
<p>The threading module provides the following synchronization primitives:</p>
<ul>
<li>Mutual exclusion locks</li>
<li>Reentrant locks</li>
<li>Conditional variables</li>
<li>Semaphores</li>
<li>Events</li>
</ul>
<p>When would you need these threads synchronization mechanisms ?</p>
<ul>
<li>When threads are updating shared data structures.</li>
<li>When threads need to coordinate their actions in some manner (events).</li>
</ul>
<h5 id="the-lock-object">The Lock object</h5>
<p>Provides a simple mutual exclusion lock. Only one thread is allowed to acquire the lock at once. Most useful for coordinating access to shared data.</p>
<blockquote>
<p>import threading</p>
</blockquote>
<blockquote>
<p>data = [ ]Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  # Some data</p>
</blockquote>
<blockquote>
<p>lck = threading.Lock()Â Â Â Â Â Â Â Â Â Â Â  # Create a lock</p>
</blockquote>
<blockquote>
<p>def put_obj(obj):</p>
</blockquote>
<blockquote>
<p>Â Â Â  lck.acquire()</p>
</blockquote>
<blockquote>
<p>Â Â Â  data.append(obj)</p>
</blockquote>
<blockquote>
<p>Â Â Â  lck.release()</p>
</blockquote>
<blockquote>
<p>def get_obj():</p>
</blockquote>
<blockquote>
<p>Â Â Â  lck.acquire()</p>
</blockquote>
<blockquote>
<p>Â Â Â  r = data.pop()</p>
</blockquote>
<blockquote>
<p>Â Â Â  lck.release()</p>
</blockquote>
<blockquote>
<p>Â Â Â  return r</p>
</blockquote>
<h5 id="the-rlock-object">The RLock object</h5>
<p>A mutual-exclusion lock that allows repeated acquisition by the same thread. Allows nested acquire(), release() operations in the thread that owns the lock. Only the outermost release() operation actually releases the lock.</p>
<blockquote>
<p>import threading</p>
</blockquote>
<blockquote>
<p>data = [ ]Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  # Some data</p>
</blockquote>
<blockquote>
<p>lck = threading.Lock()Â  # Create a lock</p>
</blockquote>
<blockquote>
<p>def put_obj(obj):</p>
</blockquote>
<blockquote>
<p>Â Â Â  lck.acquire()</p>
</blockquote>
<blockquote>
<p>Â Â Â  data.append(obj)</p>
</blockquote>
<blockquote>
<p>Â Â Â  &hellip;</p>
</blockquote>
<blockquote>
<p>Â Â Â  put_obj(otherobj)Â Â  # Some kind of recursion</p>
</blockquote>
<blockquote>
<p>Â Â Â  &hellip;</p>
</blockquote>
<blockquote>
<p>Â Â Â  lck.release()</p>
</blockquote>
<blockquote>
<p>def get_obj():</p>
</blockquote>
<blockquote>
<p>Â Â Â  lck.acquire()</p>
</blockquote>
<blockquote>
<p>Â Â Â  r = data.pop()</p>
</blockquote>
<blockquote>
<p>Â Â Â  lck.release()</p>
</blockquote>
<blockquote>
<p>Â Â Â  return r</p>
</blockquote>
<h5 id="the-condition-object">The Condition object</h5>
<p>Creates a condition variable. Synchronization primitive typically used when a thread is interested in an event or state change. Could help in the producer-consumer classic problem.</p>
<blockquote>
<p>data = []Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  # Create data queue and a condition variable</p>
</blockquote>
<blockquote>
<p>cv = threading.Condition()</p>
</blockquote>
<blockquote>
<p># Consumer thread</p>
</blockquote>
<blockquote>
<p>def consume_item():</p>
</blockquote>
<blockquote>
<p>Â Â Â  cv.acquire()Â Â Â Â Â Â Â Â Â Â Â Â Â  # Acquire the lock</p>
</blockquote>
<blockquote>
<p>Â Â Â  while not len(data):</p>
</blockquote>
<blockquote>
<p>Â Â Â Â Â Â Â  cv.wait()Â Â Â Â Â Â Â Â Â Â Â Â  # Wait for data to show up</p>
</blockquote>
<blockquote>
<p>Â Â Â  r = data.pop()</p>
</blockquote>
<blockquote>
<p>Â Â Â  cv.release()Â Â Â Â Â Â Â Â Â Â Â Â  # Release the lock</p>
</blockquote>
<blockquote>
<p>Â Â Â  return r</p>
</blockquote>
<blockquote>
<p># Producer thread</p>
</blockquote>
<blockquote>
<p>def produce_item(obj):</p>
</blockquote>
<blockquote>
<p>Â Â Â  cv.acquire()Â Â Â Â Â Â Â Â Â Â Â  # Acquire the lock</p>
</blockquote>
<blockquote>
<p>Â Â Â  data.append(obj)</p>
</blockquote>
<blockquote>
<p>Â Â Â  cv.notify()Â Â Â Â Â Â Â Â Â Â Â Â Â  # Notify a consumer</p>
</blockquote>
<blockquote>
<p>Â Â Â  cv.release()Â Â Â Â Â Â Â Â Â Â  # Release the lock</p>
</blockquote>
<h5 id="semaphores">Semaphores</h5>
<p>A locking primitive based on a counter. Each acquire() method decrements the counter. Each release() method increments the counter. If the counter reaches zero, future acquire() methods block. Common use: limiting the number of threads allowed to execute code</p>
<blockquote>
<p>sem = threading.Semaphore(5)Â Â Â Â Â  # No more than 5 threads allowed</p>
</blockquote>
<blockquote>
<p>def fetch_file(host,filename):</p>
</blockquote>
<blockquote>
<p>Â Â Â  sem.acquire()Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  # Decrements count or blocks if zero</p>
</blockquote>
<blockquote>
<p>Â Â Â  &hellip;</p>
</blockquote>
<blockquote>
<p>Â Â Â  sem.release()Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  # Increment count</p>
</blockquote>
<h5 id="events">Events</h5>
<p>A communication primitive for coordinating threads. One thread signals an &ldquo;event&rdquo; while other threads wait for it to happen.</p>
<blockquote>
<p>e = Event()Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  # Create an event object</p>
</blockquote>
<blockquote>
<p>def signal_event():Â Â Â Â Â Â Â Â Â Â Â Â  # Signal the event</p>
</blockquote>
<blockquote>
<p>Â Â Â Â  e.set()</p>
</blockquote>
<blockquote>
<p>def wait_for_event():Â Â Â Â Â Â Â Â  # Wait for event</p>
</blockquote>
<blockquote>
<p>Â Â Â  e.wait()</p>
</blockquote>
<blockquote>
<p>def clear_event():Â Â Â Â Â Â Â Â Â Â Â Â  # Clear event</p>
</blockquote>
<blockquote>
<p>Â Â Â  e.clear()</p>
</blockquote>
<p>Event is similar to a condition variable, but all threads waiting for event are awakened.</p>
<h5 id="locks-and-blocking">Locks and Blocking</h5>
<p>By default, all locking primitives block until lock is acquired. In general, this is uninterruptible. Fortunately, most primitives provide a non-blocking option</p>
<blockquote>
<p>if not lck.acquire(0):</p>
</blockquote>
<blockquote>
<p>Â Â Â Â  # lock couldnâ€™t be acquired!</p>
</blockquote>
<p>This works for Lock, RLock, and Semaphore objects. On the other hand condition variables and events provide a timeout option</p>
<blockquote>
<p>cv = Condition()</p>
</blockquote>
<blockquote>
<p>&hellip;</p>
</blockquote>
<blockquote>
<p>cv.wait(60.0)Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  # Wait 60 seconds for notification</p>
</blockquote>
<p>On timeout, the function simply returns. Up to caller to detect errors.</p>
<h4 id="the-queue-module">The Queue Module</h4>
<p>Provides a multi-producer, multi-consumer FIFO queue object. It can be used to safely exchange data between multiple threads.</p>
<ul>
<li>q = Queue(maxsize)Â Â Â  # Create a queue.</li>
<li>q.qsize()Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  # Return current size.</li>
<li>q.empty()Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  # Test if empty.</li>
<li>q.full()Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  # Test if full.</li>
<li>q.put(item)Â Â Â Â Â Â Â Â Â Â Â Â Â Â  # Put an item on the queue.</li>
<li>q.get()Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â  # Get item from queue</li>
</ul>
<p>The Queue object also supports non-blocking put/get.</p>
<ul>
<li>q.put_nowait(item).</li>
<li>q.get_nowait()</li>
</ul>
<p>These raise the Queue.Full or Queue.Empty exceptions if an error occurs. Return values for qsize(), empty(), and full() are approximate.</p>
<h4 id="things-to-consider-when-using-threads">Things to consider when using threads</h4>
<ul>
<li>Global interpreter lock makes it difficult to fully utilize multiple CPUs.</li>
<li>You donâ€™t get the degree of parallelism you might expect.</li>
<li>Not all modules are thread-friendly. Example: gethostbyname() blocks all threads if nameserver down.</li>
</ul>
<p>In this note we will talked about threading, threads communication and synchronization. In the upcoming notes, we will talk about more advanced topics in Python programming.</p>
</div>
        </div>

        <aside class="content-browser light-border-top">
            Continue reading
            <div>
                
                    <a class="previous" href="/2009/03/python-notes-9.html">â†© Python Notes â€“ 9 : Serialization</a>
                
                 â–  
                
                    <a class="next" href="/2009/05/python-notes-11-introduction-to-network.html"> Python Notes 11 : Introduction to Network Programming â†ª</a>
                
            </div>
        </aside>
      </div>
    </section>

    <footer class="footer">
  <div class="container">
    <div class="footer__left">
      <div class="footer__copy">
        <a href="https://themes.gohugo.io/themes/adritian-free-hugo-theme">Â© Adritian</a>. Free Hugo theme by <a href="https://www.adrianmoreno.info">AdriÃ¡n Moreno PeÃ±a</a>.</br><a href="https://github.com/Ebeid/ebeid.github.io">Site content and code available in GitHub</a>.
      </div>
    </div>
    <div class="footer__links">
      <ul class="navbar-nav ">
        <li class="nav-item">
            <a class="nav-link" href="http://localhost:1313/">ğŸ  HOME</a>
        </li>
        
        <li class="nav-item">
          <a class="nav-link" href="/#about">ABOUT</a>
        </li>
        
        <li class="nav-item">
          <a class="nav-link" href="/#contact">CONTACT</a>
        </li>
        
      </ul>
    </div>
    <div class="footer__right">
      
    </div>
  </div>
</footer>
 <script>
  window.addEventListener("load", function() {
    try{
      var observer = window.lozad(".lozad", {
        rootMargin: window.innerHeight / 2 + "px 0px",
        threshold: 0.01
      }); 
      observer.observe();
    } catch(e) {
      console.error(e);
    }
  });
</script>
<script defer src='http://localhost:1313/js/rad-animations.js'></script>
<script defer src='http://localhost:1313/js/library/smooth-scroll.polyfills.min.js'></script>
<script defer src='http://localhost:1313/js/sticky-header.js'></script>
<script defer src='http://localhost:1313/js/smooth-scroll-init.js'></script>
<script defer src='http://localhost:1313/js/library/bootstrap.min.js'></script>





<script>
  window.si = window.si || function () { (window.siq = window.siq || []).push(arguments); };
</script>



  </body>
</html>

