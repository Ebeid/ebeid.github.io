---
title: The Z3 Constraint Solver, a developer perspective
date: '2013-07-30T06:30:00.000-05:00'

tags:
- Z3
- Satiability Modulo Theories
modified_time: '2013-08-13T12:23:43.430-05:00'
thumbnail: http://lh6.ggpht.com/-_oulgO08Rjs/UfbC-_W4NUI/AAAAAAAAB0g/oMAhsSkxYIY/s72-c/fileFProjectsZ3Demo1Z3Demo1binDebugZ3Demo1.EXE_2013-07-29_08-51-07_thumb%25255B1%25255D.png?imgmax=800
blogger_id: tag:blogger.com,1999:blog-59384554657271185.post-1325923284266296577
blogger_orig_url: http://ebeid-soliman.blogspot.com/2013/07/the-z3-constraint-solver-developer.html
---

<p><a title="Z3 : An Efficient Theorem Prover" href="http://research.microsoft.com/en-us/um/redmond/projects/z3/old/" target="_blank">Z3</a> is a high-performance SMT solver developed at <a title="Microsoft Research" href="http://research.microsoft.com/en-us/" target="_blank">Microsoft Research</a>. It have been integrated with many many tools that came out from Microsoft for program analysis, testing, and verification.</p> <h4>What SAT means ?</h4> <p>SAT refers to Boolean satisfiability problem where we want to determine if there exists an interpretation that satisfies a given Boolean formula. In other words, it establishes if the variables of a given Boolean formula can be assigned in such a way as to make the formula evaluate to true.</p> <h4>What SMT means ?</h4> <p>SMT stands for Satiability Modulo Theories. SMT instance is a formula in first-order logic, where some functions and predicates have additional interpretations. SMT problem is a decision problem of determining whether such a formula is satisfiable or not.</p> <p>An SMT instance is a generalization of a Boolean SAT instance in which various sets of variables are replaced by predicates over a suitable set of non-binary variables.</p> <p>These predicates are classified according to the theory they belong to. For instance, linear inequalities over real variables are evaluated using the rules of the theory of linear real arithmetic.</p> <h4>What SMT solver means ?</h4> <p>The goal of an SMT solver is to determine whether an SMT instance can evaluate to true or not. The same analog applies for SAT solvers.</p> <h4>SMT solvers</h4> <p>There is a lot of SMT solvers available but there is only one SMT solver with C# APIs, it is Z3. For a list of available SMT solvers, refer to this <a title="Satisfiability Modulo Theories" href="http://en.wikipedia.org/wiki/Satisfiability_Modulo_Theories" target="_blank">page</a>. </p> <h4>Download Z3</h4> <p>You can download Z3 from <a href="http://z3.codeplex.com/">http://z3.codeplex.com/</a> . I downloaded Z3 4.3.0 and extracted it to C:\z3.</p> <h4>C# Example</h4> <p>In the following example we going to let Z3 solve the following equation system: </p> <ul> <li>x &gt; 0  <li>y = x + 1&nbsp; <li>y &lt; 3</li></ul> <p>Solving the equations means finding values for x and y that make the whole formula evaluates to true.</p> <ul> <li>Let’s create a new console application project in Visual Studio.  <li>Add reference to <em>Microsoft.Z3.dll</em> which is located in the bin directory of the Z3 installation directory.  <li>Copy the file libz3.dll from the bin directory of the Z3 installation directory to your project build directory.  <li>Now edit your code to look like the following:</li></ul><pre class="prettyprint lang-cs">using System;<br>using Microsoft.Z3;<br><br>namespace Z3Demo1<br>{<br>    class Program<br>    {<br>        static void Main(string[] args)<br>        {<br>            using (Context ctx = new Context())<br>            {<br>                Expr x = ctx.MkConst("x", ctx.MkIntSort());<br>                Expr y = ctx.MkConst("y", ctx.MkIntSort());<br>                Expr zero = ctx.MkNumeral(0, ctx.MkIntSort());<br>                Expr one = ctx.MkNumeral(1, ctx.MkIntSort());<br>                Expr three = ctx.MkNumeral(3, ctx.MkIntSort());<br>                <br>                Solver s = ctx.MkSolver();<br>                s.Assert(ctx.MkAnd(ctx.MkGt((ArithExpr)x, (ArithExpr)zero), ctx.MkEq((ArithExpr)y, <br>                    ctx.MkAdd((ArithExpr)x, (ArithExpr)one)), ctx.MkLt((ArithExpr)y, (ArithExpr)three)));<br>                Console.WriteLine(s.Check());<br><br>                Model m = s.Model;<br>                foreach (FuncDecl d in m.Decls)<br>                        Console.WriteLine(d.Name + " -&gt; " + m.ConstInterp(d));<br>                    <br>                Console.ReadLine();<br>            }<br>        }<br>    }<br>}<br></pre><br><br /><p>Now let’s run the code above and see the output. The solver says the equation system is satisfiable and then gives us the x and y values that satisfy.
</p><br><br /><p><a href="http://lh5.ggpht.com/-9rk9PdkdmKw/UfbC-RmJw4I/AAAAAAAAB0Y/tKHMbwujGC8/s1600-h/fileFProjectsZ3Demo1Z3Demo1binDebugZ3Demo1.EXE_2013-07-29_08-51-07%25255B3%25255D.png"><img style="background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px" title="fileFProjectsZ3Demo1Z3Demo1binDebugZ3Demo1.EXE_2013-07-29_08-51-07" border="0" alt="fileFProjectsZ3Demo1Z3Demo1binDebugZ3Demo1.EXE_2013-07-29_08-51-07" src="http://lh6.ggpht.com/-_oulgO08Rjs/UfbC-_W4NUI/AAAAAAAAB0g/oMAhsSkxYIY/fileFProjectsZ3Demo1Z3Demo1binDebugZ3Demo1.EXE_2013-07-29_08-51-07_thumb%25255B1%25255D.png?imgmax=800" width="134" height="84"></a></p><br><br /><h4>How it works ?</h4><br><br /><p>To interact with Z3 through C#, you need a <a title="Context Class Reference" href="http://research.microsoft.com/en-us/um/redmond/projects/z3/class_microsoft_1_1_z3_1_1_context.html" target="_blank">Context</a> object. Variables and numerals in your equations are modeled as <a title="Expr Class Reference" href="http://research.microsoft.com/en-us/um/redmond/projects/z3/class_microsoft_1_1_z3_1_1_expr.html" target="_blank">Expr</a> objects. You get these objects using member functions in the Context object (MkConts(), MkNumeral(),….). You construct your operand using member functions in the Context object (MkGt(), MkAdd(), MkLt(),…). To solve all the equations together you need to hock them up using AND operator, which is implemented using Context.MkAnd(). After hocking everything in one AND, you pass that the solver through <a title="Solver Class Reference" href="http://research.microsoft.com/en-us/um/redmond/projects/z3/class_microsoft_1_1_z3_1_1_solver.html" target="_blank">Solver</a>.Assert(). And as you may guessed, you obtain this Solver using Context.MkSolver().</p><br><br /><p>Solver.Check() will tell you whether this equation system can be solved or not. To get the variables’ assignments that the come up with, get a Model object Solver.Model. Then use the Delcs collection to get all symbols that have an interpretation in the model. Model.ConstInterp() will get the symbol assigned value.</p><br><br /><p>In this post we briefly introduced SAT, SMT, and their solvers. Then we explored the only SMT solver that written in C# and had a C# API. Now you can play with as many equations as you want and check them for satisfiability and even got the solution values.</p>
